<!DOCTYPE html>
<html lang="pt-bt">
	<head>
		<link href="estilos/limpo.css" type="text/css" media="all" rel="stylesheet" />
		<link href="estilos/documento.css" type="text/css" media="all" rel="stylesheet" />
		<meta charset="utf-8" />
		<title>Webis: Linguagem e ambiente Web acessível de programação</title>
	</head>
	<body>
		<section class="capa">
			<header>
				<p>Universidade Federal de Santa Catarina</p>
				<p>Centro Tecnológico</p>
				<p>Departamento de Informática e Estatística</p>
				<p>Curso de Ciências da Computação</p>
			</header>
			<hgroup>
				<h1>Webis:</h1>
				<h2>Linguagem e ambiente Web acessível de programação</h2>
			</hgroup>
			<section>
				<p>Lucas Pereira da Silva</p>
			</section>
			<footer>
				<address>Florianópolis</address>
				<time datetime="2012-12">Julho de 2012</time>
			</footer>
		</section>
		<section class="preTextual">
			<h1 id="sumario">Sumário</h1>
			<ol>
				<h1><a href="#introducao">Introdução</a></h1>
				<!-- <h2><a href="#objetivoGeral">Objetivo geral</a></h2>
				<h2><a href="#objetivosEspecificos">Objetivos específicos</a></h2>
				<h2><a href="#dificuldadesNoAprendizado">Dificuldades no aprendizado de linguagens de programação por pessoas com deficiência visual</a></h2> -->
				<h1><a href="#definicaoDaLinguagem">Definição da linguagem baseada em Telis</a></h1>
				<!-- <h2><a href="#gramatica">Gramática</a></h2> -->
				<h1><a href="#maquinaWebis">Máquina Webis</a></h1>
				<!-- <h2><a href="#geracaoDeCodigo">Geração de código JavaSCript</a></h2>
				<h2><a href="#coracaoDaMaquina">Coração da máquina</a></h2>
				<h2><a href="#excecoes">Exceções<a></h2> -->
				<h1 class="naoNumerado"><a href="#referencias">Referências bibliográficas</a></h1>
			</ol>
		</section>
		<section class="preTextual">
			<h1 id="listaDeFiguras">Lista de figuras</h1>
			<ol>
			</ol>
		</section>
		<section class="preTextual">
			<h1 id="listaDeListagens">Lista de listagens</h1>
			<ol>
			</ol>
		</section>
		<section class="textual">
			<h1 id="introducao"><a href="#sumario">Introdução</a></h1>
			<p>A facilidade no aprendizado de uma primeira linguagem de programação está relacionada com a própria linguagem que é objeto de estudo e também com o ambiente de programação a ser utilizado. Boa parte das linguagens não possuem regras sintáticas e semânticas simples e tão pouco oferecem um ambiente de programação simplificado e intuitivo. Isso ocorre, pois na maioria dos casos, as linguagens de programação são desenvolvidas para serem ferramentas profissionais e não de aprendizado <a href="#referencia1"><cite class="parenteses">Gomes; Mendes, <time>2012</time></cite></a>. Em decorrência desse fato, o primeiro contato com uma linguagem de programação pode ser muitas vezes traumático, fazendo com que o programador iniciante perca o interesse.</p>
			<p>A linguagem Telis, desenvolvida no <dfn>Laboratório de Software Educacional <abbr title="Laboratório de Software Educacional">Edugraf</abbr></dfn>, possui regras sintáticas e semânticas simples que podem ser facilmente assimiladas. Telis também é o nome do ambiente de programação oferecido para a linguagem. Um programa Telis pode ser executado em um navegador Web através do uso de <i lang="en">applets</i> Java <a href="#referencia2"><cite class="parenteses">Pieri <i lang="la"> et al</i>, <time>2009</time></cite></a>.</p>
			<p><a href="#referencia3"><cite>Saviski <time>2010</time></cite></a>, propôs o porte da linguagem Telis para execução nativa em navegadores Web sem a necessidade da utilização de <i lang="en">applets</i>. A abordagem adotada foi a de gerar em JavaScript (linguagem interpretada nativamente pelos navegadores) o código escrito em Java da já existente máquina Telis.</p>
			<p>O presente projeto terá embasamento no projeto desenvolvido por <a href="#referencia3"><cite>Saviski <time>2010</time></cite></a> e consistirá do desenvolvimento de uma linguagem baseada em Telis e de uma máquina de execução escrita diretamente em JavaScript. O projeto também deverá ter grande foco no ambiente de programação que deverá ser executado nativamente por navegadores Web. O novo ambiente e a nova linguagem de programação a serem desenvolvidos serão chamados doravante de Webis.</p>
			<p>A importância de um ambiente de programação acessível está no fato de possibilitar que qualquer pessoa possa aprender uma primeira linguagem de programação de maneira fácil e sem ter que se deparar com barreiras de acessibilidade. Garantir a acessibilidade é permitir que uma pessoa cega, por exemplo, possa utilizar o ambiente sem maiores dificuldades.</p>
			<p>Projetos como o Eclipse Orion mostram que é possível realizar o desenvolvimento de um ambiente de programação que execute diretamente nos navegadores. O Eclipse Orion é um editor de texto para o desenvolvimento de aplicações Web escritas em <abbr lang="en" title="Hypertext Markup Language">HTML</abbr>, JavaScript e <abbr lang="en" title="Cascading Style Sheet">CSS</abbr>. Uma de suas principais ideias é fazer com que não só as aplicações executem na Web, mas também o próprio ambiente de programação.</p>
			<p>A utilização da Web como plataforma se encaixa muito bem nos requisitos de um ambiente acessível. Além de ser um sistema distribuído de baixo acoplamento, a Web se mostra uma ótima plataforma para a execução de aplicações, pois permite a manipulação de recursos <i lang="en">online</i> e gera independência da aplicação para com o sistema operacional. A <dfn>Linguagem de Marcação de Hipertexto 5 <abbr lang="en" title="Hypertext Markup Language 5">HTML5</abbr></dfn> introduz de maneira acessível novos recursos essenciais que ainda não eram suportados de forma padronizada pela Web. Isso garante ao usuário uma acessibilidade adequada e permite que ele se familiarize desde os primeiros passos no aprendizado de uma linguagem de programação com o desenvolvimento de aplicações que executem na Web.</p>
			<h2 id="objetivoGeral"><a href="#sumario">Objetivo geral</a></h2>
			<p>Desenvolver uma linguagem de programação baseada em Telis e um ambiente acessível de programação. Tanto o ambiente de programação quanto os programas gerados pela linguagem deverão executar nativamente em navegadores Web sem a necessidade da utilização de extensões. A linguagem deverá priorizar a acessibilidade de programadores e usuários cegos possibilitando a utilização e manipulação de sons 3D que poderão ser usados  para a criação de aplicações mais ricas e acessíveis.</p>
			<h2 id="objetivosEspecificos"><a href="#sumario">Objetivos específicos</a></h2>
			<ul>
				<li>Definir uma linguagem de programação com sintaxe e semântica baseada em Telis.</li>
				<li>Desenvolver o ambiente Web de execução para a linguagem definida.</li>
				<li>Desenvolver o ambiente Web de programação para a linguagem definida.</li>
				<li>Garantir a acessibilidade dos ambientes de execução e de programação desenvolvidos.</li>
				<li>Disponibilizar na linguagem elementos que permitam a utilização e manipulação de sons 3D.</li>
			</ul>
			<h2 id="dificuldadesNoAprendizado"><a href="#sumario">Dificuldades no aprendizado de linguagens de programação por pessoas com deficiência visual</a></h2>
			<p>O crescente número de linguagens de programação aliado com a alta demanda por profissionais que dominem essas linguagens fazem com que a procura por cursos que englobem a área tenha crescido muito. Além de existir um deficit de pessoas que saibam programar, a formação de novos programadores é um processo relativamente difícil, principalmente quando o aluno é uma pessoa com deficiência visual. Em geral, a dificuldade intrínseca no aprendizado de uma linguagem de programação já torna todo processo bastante complexo. Visando diminuir a dificuldade envolvida nesse aprendizado, os cursos, livros, artigos e outros recursos educativos fazem bastante uso de imagens, diagramas e outros tipos de abstrações que podem facilitar a compreenção de determinado conceito <a href="#referencia6"><cite class="parenteses">Smith <i lang="la"> et al</i>, <time>2000</time></cite></a>. Entretanto, isso gera uma barreira extra de dificuldade para alunos com deficiência visual.</p>
			<p>As imagens servem justamente para facilitar e agilizar a explicação de um determinado conceito que seria compreendido com mais dificuldade caso fosse explicado textualmente. Porém, no caso de alunos com deficiência visual e que utilizam leitores de tela, a leitura de um texto informando sobre o que a imagem representa se torna necessária. O maior problema é que nem todas imagem irão possuir uma representação textual alternativa e nesses casos, o aluno não tem acesso total aos conteúdos educativos.</p>
			<p>Outra barreira extra encontrada por alunos com deficiência visual está no aspecto que envolve os sentidos sensoriais utilizados no aprendizado. A audição, ao contrário da visão, não é sintética. Isso signifca que no caso de um programa de computador, caso aluno tenha interesse em uma parte específica do programa, ele precisa percorrer sequêncialmente todo o conteúdo existente até alcançar a parte de seu interesse. Por isso, linguagens com construções sintáticas longas e complexas dificultam ainda mais o aprendizado do aluno.</p>
			<p>Linguagens como Logo, Smaltalk e o próprio Telis, criadas através de uma abordagem educaional e que visam se aproximar do usuário final, facilitam o aprendizado de programadores iniciantes. O principal problema de algumas dessas linguagens para alunos que necessitem da utilização de leitores de tela é o fato de serem bastante focadas em programação visual <a href="#referencia7"><cite class="parenteses">Sánchez; Aguayo, <time>2005</time></cite></a>.</p>
			<p>Além dessas, outra dificuldade encontrada por pessoas com deficiência visual é em relação a própria acessibilidade, seja dos livros, apostilas e conteúdos eletrônicos, seja dos próprios ambientes de programação. Funcionalidades não acessíveis através do teclado, desorganização de conteúdo, falta de representação alternativa para elementos não textuais e conteúdos não objetivos são apenas algumas das dificuldades encontradas por pessoas que dependem de leitores de tela. Por isso, não basta apenas que exista uma linguagem de programação que permita que uma pessoa com deficiência visual possa se expressar de forma adequada para construir os seus programas de computador. Mais do que isso, é necessário que exista um ambiente de programação que ofereça uma acessibilidade adequada.</p>
		</section>
		<section class="textual">
			<h1 id="definicaoDaLinguagem"><a href="#sumario">Definição da linguagem baseada em Telis</a></h1>
			<p>A linguagem Telis que vem sendo desenvolvida desde <time>1988</time> <a href="#referencia4"><cite class="parenteses">Pieri, <time>2007</time></cite></a> pelo <abbr title="Laboratório de Software Educacional">Edugraf</abbr>, permite, através de construções sintáticas e semânticas simples, que o programador tenha um grande poder de expressão e possa expor de forma natural conceitos avançados como orientação a objetos, paralelismo, programação distribuída, programação de eventos e outros.</p>
			<p>A linguagem Webis será criada a partir da linguagem Telis. As construções léxicas e sintáticas da nova linguagem serão muito semelhantes as mesmas existentes em Telis e a diferença entre as duas linguagens estará principalmente relacionada com os novos requisitos da linguagem Webis. Por exemplo, como Webis deverá ter suporte a manipulação de sons 3D, será necessário que esses recursos sejam incorporados a nova linguagem.</p>
			<p>Outra diferença entre a linguagem Telis e Webis estará na forma de comunicação utilizada. Em Telis é possível realizar a comunicação direta e imperativa da mesma forma que existe na orientação a objetos. É possível também realizar a comunicação através de estímulos baseados em tuplas. Webis usará apenas a segunda forma de comunicação.</p>
			<p>A linguagem Webis, portanto, deverá ser constituída pela junção de um subconjunto de funcionalidades da linguagem Telis com um conjunto de novas funcionalidades específicas para a linguagem Webis. A sintaxe das duas linguagens, entretanto, será praticamente a mesma, tendo apenas algumas pequenas diferenças.</p>
			<h2 id="gramatica"><a href="#sumario">Gramática</a></h2>
			<p>A linguagem Webis pode ser expressa através de uma gramática livre de contexto do tipo LL. Gramáticas do tipo LL possuem um conjunto adicional de restrições que permitem que a gramática possa ser analisada por um <i lang="en">parser</i> preditivo determinístico, ou seja, sem <i lang="en">backtracking</i>. Analisadores do tipo LL possuem ainda um parâmetro <var>k</var> chamado de <i lang="en">lookahed</i>. Esse parâmetro indica a quantidade de símbolos que serão levados em consideração em um passo do algoritmo. Quanto maior é o valor de <var>k</var> mais lento é o processo de análise e, em contra partida, menor é o número de não fatorações que uma produção da gramática pode conter. Uma gramática é dita fatorada se ela não possui produções que derive sequências que inicie com o mesmo <i lang="en">token</i> por mais de um caminho.</p>
			<p>Considerando um exemplo onde <var>k</var> é igual a um, então a gramática não pode ter nenhum símbolo não fatorado. Já se <var>k</var> é igual a dois, então a gramática pode conter apenas produções com no máximo um símbolo não fatorado.</p>
			<p>A gramática do Webis descrita em <abbr lang="en" title="Extended Backus Normal Form">EBNF</abbr> é mostrada na <a href="#listagemGramaticaDoWebis">Listagem 2.1</a>.</p>
			<figure class="listagem" id="listagemGramaticaDoWebis">
				<pre>
					<ol>
						<li>programa ::= (palavra | lista | COMENTARIO)*</li>
						<li>palavra ::=</li>
						<li>    atribuicao |</li>
						<li>    instanciacao |</li>
						<li>    simbolo |</li>
						<li>    texto |</li>
						<li>    numero |</li>
						<li>    operador |</li>
						<li>    booleano</li>
						<li>lista ::= "[" (palavra | lista)* "]"</li>
						<li>simbolo ::= &lt;IDENTIFICADOR&gt;</li>
						<li>atribuicao ::= &lt;IDENTIFICADOR&gt; "associar"</li>
						<li>instanciacao ::= &lt;IDENTIFICADOR&gt; ("novo" | "nova")</li>
						<li>texto ::= &lt;TEXTO&gt;</li>
						<li>numero ::= &lt;NUMERO&gt;</li>
						<li>operador ::= "+" | "-" | "=" | "*" | "/" | "\" | "^"</li>
						<li>booleano ::= "verdadeiro" | "falso"</li>
					</ol>
				</pre>
				<figcaption>Gramática EBNF do Webis.</figcaption>
			</figure>
			<p>Os itens entre parênteses angulares são definidos através de expressões regulares e foram omitidos para facilitar a leitura e diminuir o tamanho da gramática. Seus nomes são auto-explicativos e com exceção do <code>&lt;IDENTIFICADOR&gt;</code> dispensam maiores explicações. O <code>&lt;IDENTIFICADOR&gt;</code> é uma sequência de caracteres alfanuméricos que deve iniciar por uma letra e não contem espaços.</p>
			<p>Em gramáticas do tipo LL(k), o valor mínimo de <var>k</var> é dependente da linguagem. Existem linguagens onde nem sempre é possível construir uma gramática que seja completamente fatorada, ou seja, onde <var>k</var> é igual a um. Esse é o caso do Webis que possui uma gramática do tipo LL(2). A não fatoração no Webis ocorre na produção <code>palavra</code>, pois nela é possível que um <code>&lt;IDENTIFICADOR&gt;</code> seja derivado por três caminhos diferentes: pelas produções <code>simbolo</code>, <code>atribuicao</code> e <code>instanciacao</code>.</p>
			<p>Essa não fatoração gera um não determinismo, pois o analisador não sabe por qual caminho seguir quando encontra um <code>&lt;IDENTIFICADOR&gt;</code>. Para resolver esse problema é necessário que o algoritmo possa receber como entrada os dois próximos <i lang="en">tokens</i> e não apenas um. Com isso, ao perceber um <code>&lt;IDENTIFICADOR&gt;</code>, o analisador deverá ver qual é o próximo <i lang="en">token</i> para saber por qual produção a derivação irá seguir.</p>
			<p>Apesar da gramática do Webis requerer um analisador do tipo LL(2) e este ser mais lento se comparado a um do tipo LL(1), isso não vem a ser um problema devido a boa performance dos computadores e analisadores atuais.</p>
			<h2 id="pilha"><a href="#sumario">Pilha</a></h2>
			<h2 id="primitivas"><a href="#sumario">Primitvias</a></h2>
			<h2 id="apliques"><a href="#sumario">Apliques</a></h2>
			<h2 id="modelosAgendasEAtores"><a href="#sumario">Modelos, agendas e atores</a></h2>
			<p>No Telis existe o conceito de ator. Cada ator é uma unidade independente que possui o seu próprio contexto de execução. Um ator é um exemplar de um modelo que por sua vez é composto por agendas. Já as agendas definem comportamentos inerentes ao modelo em questão. Pode-se relacionar modelos, agendas e atores com conceitos provenientes da programação orientada a objetos. Um modelo, por exemplo, pode ser relacionado com o conceito de classe. Da mesma forma, agendas estão relacionadas com métodos e atores com objetos.</p>
			<p>Um programa Telis em execução, nada mais é que a execução e interação dos diversos atores que fazem parte do programa. Cada ator é executado separadamente em sua própria <i lang="en">thread</i> e isso permite que os programadores explorem de forma natural o paralelismo. Desde os primeiros programas os alunos já utilizam programação concorrente e fazem isso de forma simples e intuitiva. Além de ter um espaço de execução próprio, os atores não possuem nenhum recurso compartilhado e possuem o seu próprio escopo de variáveis e a sua própria pilha.</p>
			<p>Na execução inicial de um programa Telis, um ator é executado e este será responsável pera criação, direta ou indireta, de todos atores que deverão ser utilizados durante o programa. Cada ator pode instanciar tantos outros atores quanto for necessário. Além disso, os atores podem, em tempo de execução, definir novos modelos, bem como definir novas agendas locais.</p>
			<figure class="listagem" id="listagemInstanciacaoDeAtor">
				<pre>
					<ul>
						<li>UmModelo novo</li>
					</ul>
				</pre>
				<figcaption>Instanciação de um ator.</figcaption>
			</figure>
			<p>As agendas definidas em um modelo contem códigos de execução. Em Telis todo modelo possui uma agenda especial, a agenda <code>iniciar</code>. Toda vez que um ator é criado, a sua agenda <code>iniciar</code> é executada. A agenda <code>iniciar</code> existe mesmo que o programador não tenha definido ela explicitamente.</p>
			<p>Em Telis os modelos e agendas são criados dinâmicamente em tempo de execução. Para realizar a criação de modelos e agendas são utilizadas as primitivas <code>incluirModelo</code> e <code>incluirAgenda</code>, respectivamente.</p>
			<figure class="listagem" id="listagemInstanciacaoDeAtor">
				<pre>
					<ul>
						<li>"mostrarTexto" [</li>
						<li>    "texto" mostrar</li>
						<li>] incluirAgenda</li>
						<li>mostrarTexto</li>
					</ul>
				</pre>
				<figcaption>Definição e execução de uma agenda local.</figcaption>
			</figure>
			<figure class="listagem" id="listagemInstanciacaoDeAtor">
				<pre>
					<ul>
						<li>"UmModelo" [</li>
						<li>    "iniciar" [</li>
						<li>        calcular </li>
						<li>    ] incluirAgenda</li>
						<li>    "calcular" [</li>
						<li>        5 2 +</li>
						<li>    ] incluirAgenda</li>
						<li>] incluirModelo</li>
					</ul>
				</pre>
				<figcaption>Definição de um modelo e suas agendas.</figcaption>
			</figure>
			<h2 id="modeloDeExecucaoTesli"><a href="#sumario">Modelo de execução</a></h2>
			<h2 id="trocaDeMensagens"><a href="#sumario">Troca de mensagens</a></h2>
		</section>
		<section class="textual">
			<h1 id="maquinaWebis"><a href="#sumario">Máquina Webis</a></h1>
			<h2 id="geracaoDeCodigo"><a href="#sumario">Geração de código JavaScript</a></h2>
			<p>As etapas de análise léxica, sintática e geração do código do Webis serão realizadas através da ferramenta <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr>. O <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr> é um gerador de analisador léxico e sintático que pode ser utilizado para a criação de interpretadores de linguagens, compiladores e outros tradutores <a href="#referencia5"><cite class="parenteses">Parr, <time>2007</time></cite></a>. No contexto desse projeto, o <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr> será utilizado para gerar em JavaScript o código escrito em Webis. Nesse sentido, o <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr> atuará como um tradutor e o código JavaScript será então executado pela máquina Webis.</p>
			<p>Para realizar a geração de código JavaScript a partir de um código Webis é necessário entender alguns conceitos da arquitetura da máquina Webis que processará o código gerado. O coração da máquina Webis será explicado em detalhes mais adiante, porém por hora é necessário compreender que cada <code>palavra</code> será traduzida para um elemento JavaScript e a máquina se encarregará de executar corretamente o elemento em questão conforme o seu tipo. Por exemplo, o <code>booleano</code> do Webis, definido na <a href="#listagemGramaticaDoWebis">Listagem 2.1</a>, será traduzido para um elemento <code>Boolean</code> do JavaScript. O mesmo irá ocorrer com o <code>texto</code>, <code>numero</code> e <code>lista</code> do Webis que serão traduzidos para elementos JavaScript dos tipos <code>String</code>, <code>Number</code> e <code>Array</code>, respectivamente. Já o <code>simbolo</code>, a <code>atribuicao</code> e a <code>instanciacao</code>, ao contrário dos demais elementos, não serão traduzidos para tipos nativos do JavaScript, mas sim para os tipos próprios <code>Simbolo</code>, <code>Associar</code> e <code>Novo</code>, respectivamente. Por fim, um <code>operador</code> que semanticamente é tratado pela máquina Webis da mesma forma que um <code>simbolo</code>, também será traduzido para um objeto JavaScript do tipo <code>Simbolo</code>.</p>
			<p>Ao analisar a gramática do Webis (<a href="#listagemGramaticaDoWebis">Listagem 2.1</a>), percebemos que um programa é composto por uma lista. Essa lista por sua vez é composta por palavras e listas. A geração de código apenas irá traduzir isso para JavaScript. Com isso, a entrada da máquina Webis será uma lista JavaScript composta por números, textos, booleanos, listas e objetos.</p>
			<h2 id="coracaoDaMaquina"><a href="#sumario">Coração da máquina</a></h2>
			<p>A máquina Webis trata-se basicamente de uma máquina de pilha onde os parâmetros necessários para as operações são desempilhados da pilha e o resultado das operações são empilhados na mesma. A entrada da máquina Webis nada mais é do que uma lista que contém os comandos do programa, sendo que cada um desses comandos é um elemento JavaScript que saberá se executar. O coração da máquina Webis, portanto, se torna muito simples. De forma simplificada, o que o núcleo da máquina Webis faz é iterar sobre a lista de comandos e enviar a ordem para cada um dos comandos se executar. Além da ordem de execução, o coração da máquina Webis fornece ao comando a ser executado o contexto do programa. Desta forma, cada comando tem acesso a pilha de dados e ao escopo de variáveis. Com isso, cada comando poderá empilhar e desempilhar elementos da pilha de dados e poderá também alterar, remover e criar variáveis.</p>
			<p>A máquina Webis pode executar tanto dados quanto operações e símbolos. Quando um dado é executado ele simplesmente é colocado na pilha e fica disponível para ser consumido por uma operação ou símbolo. Quando operações ou símbolos são executados, eles podem ou não consumir elementos da pilha para produzir ou não algum resultado. Caso a operação produza algum resultado, então este é colocado na pilha de forma que possa ser consumido por uma operação ou símbolo futuro.</p>
			<p>No Webis, um símbolo pode ser uma primitiva que é uma operação básica fornecida pela linguagem, uma agenda de um ator ou uma variável. Quando a máquina encontra um símbolo, ela tenta executá-lo para algum desses casos. Caso a máquina não consiga executar o símbolo em questão, então uma exceção é lançada e em geral isso ocorre devido a erros de programação do usuário.</p>
			<h2 id="excecoes"><a href="#sumario">Exceções</a></h2>
			<p>Devido ao fato da gramática Webis ser bastante simples, ocorrem poucas exceções em tempo de compilação. Em geral, a maioria das construções sintáticas são permitidas pela linguagem e os erros de compilação se limitam a: listas não fechadas, utilização de caracteres inválidos e textos não iniciados ou terminados por aspas. O código da <a href="#listagemErroDeCompilacao">Listagem 3.1</a> mostra um erro de compilação onde um texto não foi terminado por aspas.</p>
			<figure class="listagem" id="listagemErroDeCompilacao">
				<pre>
					<ul>
						<li>"texto " "qualquer concatenar</li>
					</ul>
				</pre>
				<figcaption>Erro de compilação do Webis.</figcaption>
			</figure>
			<p>A maioria das exceções Webis ocorrem, no entanto, na etapa de execução e são gerados pela máquina Webis. As incoerências semânticas são tratadas todas durante o processo de execução e é por isso, que apenas exceções de erros sintáticos são lançadas durante o processo de compilação. O código da <a href="#listagemErroDeExecucao">Listagem 3.2</a> mostra um erro de execução. O erro ocorre, pois na linguagem Webis o operador de exponenciação não pode ser aplicado a textos.</p>
			<figure class="listagem" id="listagemErroDeExecucao">
				<pre>
					<ul>
						<li>10 "texto" ^</li>
					</ul>
				</pre>
				<figcaption>Erro de excução do Webis.</figcaption>
			</figure>
			<h2 id="modeloDeExecucaoJavaScript"><a href="#sumario">Modelo de execução JavaScript em navegadores web</a></h2>
			<p>O JavaScript utilizado a partir de um navegador <i lang="en">web</i> possui fundamentalmente um fluxo único de execução fazendo com que não exista execução concorrente de código. Mais adiante será mostrado que o <abbr lang="en" title="Hypertext Markup Language 5">HTML5</abbr> trouxe o conceito de <i lang="en">WebWorkers</i> que permite criar vários fluxos de execução. Entretanto, na abordagem atual será deixado de lado a utilização dos <i lang="en">WebWorkers</i> e será considerado um fluxo único de execução associado a um único ator Webis.</p>
			<p>Quando um pedaço de código JavaScript é executado, ele não será interrompido até que seja finalizado. Durante a execução de um código JavaScript, eventos assíncronos podem ser disparados. O código associado a cada um desses eventos será executado, um de cada vez, somente depois que o código em execução terminar. O modelo de execução JavaScript é dito bloqueante, pois interrupções não param a execução atual de código. Em vez disso, as interrupções são enfileiradas para que possam ser chamadas após o termino da execução atual <a href="#referencia8"><cite class="parenteses">Resig; Bibeault, <time>2013</time></cite></a>. Por interrupções pode-se considerar tanto o tratamento de <a href="#eventos">eventos</a> gerados pelo navegador quanto o disparo de <a href="#temporizadores">temporizadores</a>.</p>
			<h3 id="eventos"><a href="#sumario">Eventos</a></h3>
			<p>A criação de eventos assíncronos pode ocorrer de diversas formas. O JavaScript executado em um navegador <i lang="en">web</i> permite o uso da programação dirigida a eventos. Nesse sentido, o navegador gera eventos sempre que algo que possa ser de interesse do programador aconteça. Esses eventos estão sempre associados a algum elemento e podem ser adicionados tratadores para cada um deles. Por exemplo, um evento pode ser o clique do <i lang="en">mouse</i> em um determinado botão, o carregamento de um documento ou até mesmo a digitação de uma tecla.</p>
			<p>A adição de um tratador para um determinado evento de um elemento pode ser feita através do método <code>addEventListener</code> (<a href="#listagemTratadorDeEvento">Listagem 3.3</a>). Esse método irá receber dois parâmetros: o tipo do evento e uma função que contém o código do tratador. Por sua vez, quando chamado, o tratador receberá como parâmetro um objeto que representa o evento em questão.</p>
			<figure class="listagem" id="listagemTratadorDeEvento">
				<pre>
					<ul>
						<li>elemento.addEventListner("loadend", function (evento) {</li>
						<li>    // código do tratador...</li>
						<li>});</li>
					</ul>
				</pre>
				<figcaption>Criação de um tratador de evento.</figcaption>
			</figure>
			<h3 id="temporizadores"><a href="#sumario">Temporizadores</a></h3>
			<p>Além de eventos, também é possível utilizar temporizadores para executar pedaços de código de forma assíncrona. Da mesma forma que ocorre com os eventos, os temporizadores somente podem ser disparados quando determinado código que está em execução é encerrado. Existem basicamente dois tipos de temporizadores: aqueles que são ativados apenas uma única vez e aqueles que são ativados continuamente a cada determinado período de tempo. Ambos tipos de temporizadores podem ser cancelados. Para criar um temporizador que é disparado uma única vez utiliza-se a função <code>setTimeout</code> presente no objeto global <code>window</code>. De forma análoga, para criar um temporizador que é disparado continuamente a cada intervalo de tempo, utiliza-se a função <code>setInverval</code> do mesmo objeto.</p>
			<figure class="listagem" id="listagemTemporizador">
				<pre>
					<ul>
						<li>var identificador = window.setTimetout(function () {</li>
						<li>    // código do tratador...</li>
						<li>}, 1000);</li>
					</ul>
				</pre>
				<figcaption>Ativação de um temporizador que será disparado após um período de tempo.</figcaption>
			</figure>
			<p>A <a href="#listagemTemporizador">Listagem 3.4</a> mostra a ativação de um temporizador que quando disparado irá executar a função que é passada como parâmetro. O segundo parâmetro indica o tempo, a partir do momento da ativação, até que o temporizador seja efetivamente disparado. No casso em questão, o tempo de espera até o disparo será de 1 segundo (ou 1000 milisegundos). Destaca-se o fato de que esse tempo de espera não é garantido. Por exemplo, se o código que realizou a ativação do temporizador continue a executar por mais de um segundo, então o temporizador ativado terá seu disparo adiado. Isso significa que mesmo que o disparo do temporizador tenha sido programado para 1 segundo após o sua ativação, o disparo não necessáriamente irá acontecer no momento planejado. Como já visto anteriormente o modelo de exeução JavaScript em navegadores <i lang="en">web</i> é bloqueante. Por isso, mesmo que seja hora de disparar um temporizador é possível que algum outro código esteja em execução e, nesse caso, o disparo deverá ser adiado.</p>
			<figure class="listagem" id="listagemTemporizadorContinuo">
				<pre>
					<ul>
						<li>var identificador = window.setInterval(function () {</li>
						<li>    // código do tratador...</li>
						<li>}, 1000);</li>
					</ul>
				</pre>
				<figcaption>Ativação de um temporizador que será disparado continuamente a cada período de tempo.</figcaption>
			</figure>
			<p>A <a href="#listagemTemporizador">Listagem 3.5</a> mostra a ativação de um temporizador semelhante ao mostrado na <a href="#listagemTemporizador">Listagem 3.4</a>. A diferença entre ambos está no fato de que no caso deste último, o temporizador será disparado uma única vez após um determinado período de tempo, enquanto que no primeiro o disparo irá ocorrer continuamente a cada período de tempo.</p>
			<p>Ambos temporizadores podem ser cancelados a qualquer momento e, por isso, as duas funções retornam um <code>identificador</code> que é utilizado pelas funções <code>clearTimeout</code> e <code>clearInterval</code> para cancelar temporizadores disparados.</p>
			<figure class="listagem" id="listagemTemporizador">
				<pre>
					<ul>
						<li>window.clearTimeout(identificador1);</li>
						<li>window.clearInterval(identificador2);</li>
					</ul>
				</pre>
				<figcaption>Cancelamento de temporizadores previamente ativados.</figcaption>
			</figure>
			<h3 id="execucaoEmFluxoUnico"><a href="#sumario">Execução em fluxo único</a></h3>
			<p>Devido ao natureza de execução em fluxo único, apenas um pedaço de código é executado por vez no JavaScript. Assim que uma página <i lang="en">web</i> encontra um código JavaScript, ela irá carregar, analisar e por fim executar o código em questão.</p>
			<p>O fluxo único de execução responsável por executar o código JavaScript também é responsável pela redenrização do documento no navegador. Isso significa que enquanto um pedaço de código estiver sendo executado, não será realizada a renderização do documento e o inverso também é verdadeiro. Essa exclusão mútua é compreendida levando-se em conta o fato de que é possível manipular o documento através do JavaScript. Assim, a execução de determinada parte de código não bloqueia apenas a execução de outras partes, mas também a interface gráfica com o usuário e a execução de qualquer evento ou temporizador.</p>
			<p>A <a href="#figuraExecucaoEmFluxoUnico">Figura 3.1</a> facilita a compreensão do modelo de execução. Ela representa a linha temporal de execução do JavaScript em um navegador <i lang="en">web</i>. Cada bloco representa um pedaço de código JavaScript em execução e o tamanho do bloco indica quanto tempo durou a execução do bloco em questão (em milisegundos). No lado direito da imagem são indicados disparos e ativações de temporizadores e ocorrências de eventos. Nota-se também que algums disparos são canceladas (<i lang="en">dropped</i>).</p>
			<ol>
				<li>No instante de tempo 0 é executado um bloco de código JavaScript que tem duração de 18 milisegundos. Durante a execução desse código ocorre a ativação (mas não o disparo) de dois temporizadores sendo um deles um temporizador contínuo. Além dos temporizadores também ocorre um evento relacionado ao clique do <i lang="en">mouse</i>. No instante de tempo 12 deveria ocorrer o disparo do temporizador ativado anteriormente, porém isso não ocorre pois o proprio código que ativou o temporizador ainda está em execução. Com isso o disparo do temporizador é adiado.</li>
				<li>Ao encerrar a execução do bloco de código nos 18 milisegundos, o próximo passo é escalonar o próximo bloco de execução. O navegador percebe então que naquele momento existem dois blocos de código possíveis de serem executados: o tratamento de um evento do <i lang="en">mouse</i> e o disparo do temporizador que foi anteriormente adiado. O navegador escalona o tratamento do evento do <i lang="en">mouse</i>.</li>
				<li>Durante o tratamento do evento do <i lang="en">mouse</i>, que dura dos 18 aos 29 milisegundos, deveria ocorrer o disparo do temporizador contínuo (previamente ativado), porém, assim como ocorreu com o temporizador, o temporizador contínuo também é adiado para posterior execução.</li>
			</ol>
			<figure class="figura" id="figuraExecucaoEmFluxoUnico">
				<img src="imagens/modeloDeExecucaoJavaScript.png" />
				<figcaption>Modelo de execuçao JavaScript em fluxo único.</figcaption>
			</figure>
			<h3 id="webWorkers"><a href="#sumario">WebWorkers e paralelismo</a></h3>
			<h4 id="ecossistema"><a href="#sumario">Ecossistema</a></h4>
			<h2 id="pilhaDeExecucao"><a href="#sumario">Pilha de execução</a></h2>
			<p>Conforme mostrado na <a class="correcao" href="#modeloDeExecucaoTelis">seção X.Y</a>, o modelo de execução do Telis é não bloqueante. Isso significa que o ator poderá ser interrompido enquanto estiver em execução. Quando isso ocorrer o ator irá parar sua execução e irá tratar a interrupção em questão. Além disso, o ator tratará apenas uma interrupção por vez e poderá perder interrupções enquanto estiver tratando outra.</p>
			<p>Uma particulariedade no modelo de execução do Telis está relacionada com a primitiva descansar. Quando esta primitiva é executada, ela faz com que o ator fique bloqueado por um determinado período de tempo. Entretanto ao ter sua execução bloqueada, o ator poderá continuar tratando eventuais interrupções.</p>
			<p>Através da <a class="correcao" href="#modeloDeExecucaoJavaScript">seção X.Y</a> percebe-se que o modelo de execução do JavaScript difere do modelo de execução do Telis. Em especial, essas diferenças podem causar três problemas que dificultam a implementação do Telis através do JavaScript. O primeiro problema está relacionado com a primitiva descansar. No caso do JavaScript não é possível bloquear o programa em execução por um determinado período de tempo da mesma forma como ocorre no Java (através do método <code>sleep</code>), por exemplo. O mais próximo que se pode chegar disso é simular esse comportamento através da função <code>setTimeout</code>.</p>
			<p>O segundo problema ocorre pois o JavaScript é bloqueante e, por isso, quando um trecho de código é executado, o programa não pode ser interrompido até que o trecho termine.</p>
			<p>Por fim, o último aspecto que difere no modelo de execução do Telis e do JavaScript é que neste último nenhuma interrupção é perdida. No Telis caso uma interrupção ocorra enquanto outra está sendo executada, então a interrupção que surgiu é descartada. Já no JavaScript se o mesmo caso ocorrer, então a nova interrupção é colocada em uma fila para ser posteriormente executada.</p>
			<p>Focando no escopo de um único ator é necessário realizar alguns passos para adequar o modelo de execução do Telis ao JavaScript:</p>
			<ul>
				<li>Permitir que após um ator ser instânciado, este possa receber interrupções de estímulos.</li>
				<li>Descartar interrupções que surgirem caso o ator esteja tratando uma outra interrupção.</li>
				<li>A primitiva <code>descansar</code> deverá parar a execução do ator ou de uma eventual interrupção. Além disso, caso um ator esteja parado em função da primitiva e uma interrupção surja,então é necessário que o tempo de descanso estipulado pelo ator seja descontado do tempo de demora da execução da interrupção.</li>
			</ul>
			<h3 id="padraoEstado"><a href="#sumario">Padrão estado</a></h3>
		</section>
		<section class="posTextual">
			<h1 id="referencias"><a href="#sumario">Referências bibliográficas</a></h1>
			<p id="referencia1">
				GOMES, Anabela; MENDES, A. J.
				<strong lang="en">Learning to program</strong>:
				<span lang="en">difficulties and solutions</span>.
				<span lang="en">International Conference on Engineering Education</span>,
				Coimbra, Portugal, 2007.
			</p>
			<p id="referencia2">
				PIERI, Giovani <i lang="la">et al</i>.
				<strong lang="en">Telis</strong>:
				<span lang="en">a programming tool set for beginners</span>.
				<span lang="en">International Information And Telecommunication Technologies Symposium</span>, Florianópolis, Santa Catarina, Brasil, 2009. p. 183-186.
			</p>
			<p id="referencia3">
				SAVISKI, Marcelo.
				<strong>Porte de uma linguagem de programação para execução nativa em navegadores Web</strong>.
				Curso de Ciências da Computação, Departamento de Informática e Estatística, Universidade Federal de Santa Catarina,
				Florianópolis, Santa Catarina, Brasil, 2010.
			</p>
			<p id="referencia4">
				PIERI, Giovani.
				<strong>Projeto e implementação de uma linguagem de programação</strong>.
				Curso de Ciências da Computação, Departamento de Informática e Estatística, Universidade Federal de Santa Catarina,
				Florianópolis, Santa Catarina, Brasil, 2007.
			</p>
			<p id="referencia5">
				PARR, Terence.
				<strong lang="en">The definitive ANTLR reference</strong>:
				<span lang="en">Building domain-specific languages</span>.
				<span lang="en">The Pragmatic Bookshelf</span>,
				2007. 358 p.
			</p>
			<p id="referencia6">
				SMITH, Ann C. <i lang="la">et al</i>.
				<strong lang="en">A Java programming tool for students with visual disabilities</strong>.
				<span lang="en">Proceedings of the fourth international ACM conference on Assistive technologies</span>,
				Arlington, Virginia, USA, 2000. p. 142-148.
			</p>
			<p id="referencia7">
				SÁNCHEZ, Jaime; AGUAYO, Fernando.
				<strong lang="en">Blind learners programming through audio</strong>.
				<span lang="en">CHI '05 Extended Abstracts on Human Factors in Computing Systems</span>,
				Portland, OR, USA, 2005. p. 1769-1772.
			</p>
			<p id="referencia8">
				RESIG, John; BIBEAULT, Bear.
				<strong lang="en">Screts of the JavaScript ninja</strong>.
				<span lang="en">Manning Publications</span>,
				Shelter Island, NY, USA, 2013. 370 p.
			</p>
			<p id="referencia99">
				CALDWELL, Ben <i lang="la">et al</i>.
				<strong lang="en">Web Content Accessibility Guidelines 2.0</strong>.
				<span lang="en">World Wide Web Consortium</span>,
				2008.
				Disponível em: <a href="http://www.w3.org/TR/WCAG/">http://www.w3.org/TR/WCAG/</a>.
				Acesso em: dezembro de 2012.
			</p>
			<p id="referencia98">
				XAVIER, Marcus Vinícius Cruz.
				<strong>Telis ME</strong>: uma versão de Telis para dispositivos móveis.
				Curso de Ciências da Computação, Departamento de Informática e Estatística, Universidade Federal de Santa Catarina,
				Florianópolis, Santa Catarina, Brasil, 2006.
			</p>
		</section>
	</body>
</html>