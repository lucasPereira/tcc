<!DOCTYPE html>
<html lang="pt-bt">
	<head>
		<link href="estilos/limpo.css" type="text/css" media="all" rel="stylesheet" />
		<link href="estilos/documento.css" type="text/css" media="all" rel="stylesheet" />
		<meta charset="utf-8" />
		<title>Webis: Linguagem e ambiente Web acessível de programação</title>
	</head>
	<body>
		<section class="capa">
			<header>
				<p>Universidade Federal de Santa Catarina</p>
				<p>Centro Tecnológico</p>
				<p>Departamento de Informática e Estatística</p>
				<p>Curso de Ciências da Computação</p>
			</header>
			<hgroup>
				<h1>Webis:</h1>
				<h2>Linguagem e ambiente Web acessível de programação</h2>
			</hgroup>
			<section>
				<p>Lucas Pereira da Silva</p>
			</section>
			<footer>
				<address>Florianópolis</address>
				<time datetime="2012-12">Julho de 2012</time>
			</footer>
		</section>
		<section class="preTextual">
			<h1 id="sumario">Sumário</h1>
			<ol>
				<h1><a href="#introducao">Introdução</a></h1>
				<!-- <h2><a href="#objetivoGeral">Objetivo geral</a></h2>
				<h2><a href="#objetivosEspecificos">Objetivos específicos</a></h2>
				<h2><a href="#dificuldadesNoAprendizado">Dificuldades no aprendizado de linguagens de programação por pessoas com deficiência visual</a></h2> -->
				<h1><a href="#definicaoDaLinguagem">Definição da linguagem baseada em Telis</a></h1>
				<!-- <h2><a href="#gramatica">Gramática</a></h2> -->
				<h1><a href="#maquinaWebis">Máquina Webis</a></h1>
				<!-- <h2><a href="#geracaoDeCodigo">Geração de código JavaSCript</a></h2>
				<h2><a href="#coracaoDaMaquina">Coração da máquina</a></h2>
				<h2><a href="#excecoes">Exceções<a></h2> -->
				<h1 class="naoNumerado"><a href="#referencias">Referências bibliográficas</a></h1>
			</ol>
		</section>
		<section class="preTextual">
			<h1 id="listaDeFiguras">Lista de figuras</h1>
			<ol>
			</ol>
		</section>
		<section class="preTextual">
			<h1 id="listaDeListagens">Lista de listagens</h1>
			<ol>
			</ol>
		</section>
		<section class="textual">
			<h1 id="introducao"><a href="#sumario">Introdução</a></h1>
			<p>A facilidade no aprendizado de uma primeira linguagem de programação está relacionada com a própria linguagem que é objeto de estudo e também com o ambiente de programação a ser utilizado. Boa parte das linguagens não possuem regras sintáticas e semânticas simples e tão pouco oferecem um ambiente de programação simplificado e intuitivo. Isso ocorre, pois na maioria dos casos, as linguagens de programação são desenvolvidas para serem ferramentas profissionais e não de aprendizado <cite class="parenteses"><a href="#referencia1">Gomes; Mendes, <time>2012</time></a></cite>. Em decorrência desse fato, o primeiro contato com uma linguagem de programação pode ser muitas vezes traumático, fazendo com que o programador iniciante perca o interesse.</p>
			<p>A linguagem Telis, desenvolvida no <dfn>Laboratório de Software Educacional <abbr title="Laboratório de Software Educacional">Edugraf</abbr></dfn>, possui regras sintáticas e semânticas simples que podem ser facilmente assimiladas. Telis também é o nome do ambiente de programação oferecido para a linguagem. Um programa Telis pode ser executado em um navegador Web através do uso de <i lang="en">applets</i> Java <cite class="parenteses"><a href="#referencia2">Pieri <i lang="la"> et al</i>, <time>2009</time></a></cite>.</p>
			<p><cite><a href="#referencia3">Saviski <time>2010</time></a></cite>, propôs o porte da linguagem Telis para execução nativa em navegadores Web sem a necessidade da utilização de <i lang="en">applets</i>. A abordagem adotada foi a de gerar em JavaScript (linguagem interpretada nativamente pelos navegadores) o código escrito em Java da já existente máquina Telis.</p>
			<p>O presente projeto terá embasamento no projeto desenvolvido por <cite><a href="#referencia3">Saviski <time>2010</time></a></cite> e consistirá do desenvolvimento de uma linguagem baseada em Telis e de uma máquina de execução escrita diretamente em JavaScript. O projeto também deverá ter grande foco no ambiente de programação que deverá ser executado nativamente por navegadores Web. O novo ambiente e a nova linguagem de programação a serem desenvolvidos serão chamados doravante de Webis.</p>
			<p>A importância de um ambiente de programação acessível está no fato de possibilitar que qualquer pessoa possa aprender uma primeira linguagem de programação de maneira fácil e sem ter que se deparar com barreiras de acessibilidade. Garantir a acessibilidade é permitir que uma pessoa cega, por exemplo, possa utilizar o ambiente sem maiores dificuldades.</p>
			<p>Projetos como o Eclipse Orion mostram que é possível realizar o desenvolvimento de um ambiente de programação que execute diretamente nos navegadores. O Eclipse Orion é um editor de texto para o desenvolvimento de aplicações Web escritas em <abbr lang="en" title="Hypertext Markup Language">HTML</abbr>, JavaScript e <abbr lang="en" title="Cascading Style Sheet">CSS</abbr>. Uma de suas principais ideias é fazer com que não só as aplicações executem na Web, mas também o próprio ambiente de programação.</p>
			<p>A utilização da Web como plataforma se encaixa muito bem nos requisitos de um ambiente acessível. Além de ser um sistema distribuído de baixo acoplamento, a Web se mostra uma ótima plataforma para a execução de aplicações, pois permite a manipulação de recursos <i lang="en">online</i> e gera independência da aplicação para com o sistema operacional. A <dfn>Linguagem de Marcação de Hipertexto 5 <abbr lang="en" title="Hypertext Markup Language 5">HTML5</abbr></dfn> introduz de maneira acessível novos recursos essenciais que ainda não eram suportados de forma padronizada pela Web. Isso garante ao usuário uma acessibilidade adequada e permite que ele se familiarize desde os primeiros passos no aprendizado de uma linguagem de programação com o desenvolvimento de aplicações que executem na Web.</p>
			<h2 id="objetivoGeral"><a href="#sumario">Objetivo geral</a></h2>
			<p>Desenvolver uma linguagem de programação baseada em Telis e um ambiente acessível de programação. Tanto o ambiente de programação quanto os programas gerados pela linguagem deverão executar nativamente em navegadores Web sem a necessidade da utilização de extensões. A linguagem deverá priorizar a acessibilidade de programadores e usuários cegos possibilitando a utilização e manipulação de sons 3D que poderão ser usados  para a criação de aplicações mais ricas e acessíveis.</p>
			<h2 id="objetivosEspecificos"><a href="#sumario">Objetivos específicos</a></h2>
			<ul>
				<li>Definir uma linguagem de programação com sintaxe e semântica baseada em Telis.</li>
				<li>Desenvolver o ambiente Web de execução para a linguagem definida.</li>
				<li>Desenvolver o ambiente Web de programação para a linguagem definida.</li>
				<li>Garantir a acessibilidade dos ambientes de execução e de programação desenvolvidos.</li>
				<li>Disponibilizar na linguagem elementos que permitam a utilização e manipulação de sons 3D.</li>
			</ul>
			<h2 id="dificuldadesNoAprendizado"><a href="#sumario">Dificuldades no aprendizado de linguagens de programação por pessoas com deficiência visual</a></h2>
			<p>O crescente número de linguagens de programação aliado com a alta demanda por profissionais que dominem essas linguagens fazem com que a procura por cursos que englobem a área tenha crescido muito. Além de existir um deficit de pessoas que saibam programar, a formação de novos programadores é um processo relativamente difícil, principalmente quando o aluno é uma pessoa com deficiência visual. Em geral, a dificuldade intrínseca no aprendizado de uma linguagem de programação já torna todo processo bastante complexo. Visando diminuir a dificuldade envolvida nesse aprendizado, os cursos, livros, artigos e outros recursos educativos fazem bastante uso de imagens, diagramas e outros tipos de abstrações que podem facilitar a compreenção de determinado conceito <cite class="parenteses"><a href="#referencia6">Smith <i lang="la"> et al</i>, <time>2000</time></a></cite>. Entretanto, isso gera uma barreira extra de dificuldade para alunos com deficiência visual.</p>
			<p>As imagens servem justamente para facilitar e agilizar a explicação de um determinado conceito que seria compreendido com mais dificuldade caso fosse explicado textualmente. Porém, no caso de alunos com deficiência visual e que utilizam leitores de tela, a leitura de um texto informando sobre o que a imagem representa se torna necessária. O maior problema é que nem todas imagem irão possuir uma representação textual alternativa e nesses casos, o aluno não tem acesso total aos conteúdos educativos.</p>
			<p>Outra barreira extra encontrada por alunos com deficiência visual está no aspecto que envolve os sentidos sensoriais utilizados no aprendizado. A audição, ao contrário da visão, não é sintética. Isso signifca que no caso de um programa de computador, caso aluno tenha interesse em uma parte específica do programa, ele precisa percorrer sequêncialmente todo o conteúdo existente até alcançar a parte de seu interesse. Por isso, linguagens com construções sintáticas longas e complexas dificultam ainda mais o aprendizado do aluno.</p>
			<p>Linguagens como Logo, Smaltalk e o próprio Telis, criadas através de uma abordagem educaional e que visam se aproximar do usuário final, facilitam o aprendizado de programadores iniciantes. O principal problema de algumas dessas linguagens para alunos que necessitem da utilização de leitores de tela é o fato de serem bastante focadas em programação visual <cite class="parenteses"><a href="#referencia7">Sánchez; Aguayo, <time>2005</time></a></cite>.</p>
			<p>Além dessas, outra dificuldade encontrada por pessoas com deficiência visual é em relação a própria acessibilidade, seja dos livros, apostilas e conteúdos eletrônicos, seja dos próprios ambientes de programação. Funcionalidades não acessíveis através do teclado, desorganização de conteúdo, falta de representação alternativa para elementos não textuais e conteúdos não objetivos são apenas algumas das dificuldades encontradas por pessoas que dependem de leitores de tela. Por isso, não basta apenas que exista uma linguagem de programação que permita que uma pessoa com deficiência visual possa se expressar de forma adequada para construir os seus programas de computador. Mais do que isso, é necessário que exista um ambiente de programação que ofereça uma acessibilidade adequada.</p>
		</section>
		<section class="textual">
			<h1 id="definicaoDaLinguagem"><a href="#sumario">Definição da linguagem baseada em Telis</a></h1>
			<p>A linguagem Telis que vem sendo desenvolvida desde <time>1998</time> <cite class="parenteses"><a href="#referencia4">Pieri, <time>2007</time></a></cite> pelo <abbr title="Laboratório de Software Educacional">Edugraf</abbr>, permite, através de construções sintáticas e semânticas simples, que o programador tenha um grande poder de expressão e possa expor de forma natural conceitos avançados como orientação a objetos, paralelismo, programação distribuída, programação de eventos e outros.</p>
			<p>A linguagem Webis será criada a partir da linguagem Telis. As construções léxicas e sintáticas da nova linguagem serão muito semelhantes as mesmas existentes em Telis e a diferença entre as duas linguagens estará principalmente relacionada com os novos requisitos da linguagem Webis. Por exemplo, como Webis deverá ter suporte a manipulação de sons 3D, será necessário que esses recursos sejam incorporados a nova linguagem.</p>
			<p>Outra diferença entre a linguagem Telis e Webis estará na forma de comunicação utilizada. Em Telis é possível realizar a comunicação direta e imperativa da mesma forma que existe na orientação a objetos. É possível também realizar a comunicação através de estímulos baseados em tuplas. Webis usará apenas a segunda forma de comunicação.</p>
			<p>A linguagem Webis, portanto, deverá ser constituída pela junção de um subconjunto de funcionalidades da linguagem Telis com um conjunto de novas funcionalidades específicas para a linguagem Webis. A sintaxe das duas linguagens, entretanto, será praticamente a mesma, tendo apenas algumas pequenas diferenças.</p>
			<h2 id="gramatica"><a href="#sumario">Gramática</a></h2>
			<p>A linguagem Webis pode ser expressa através de uma gramática livre de contexto do tipo LL. Gramáticas do tipo LL possuem um conjunto adicional de restrições que permitem que a gramática possa ser analisada por um <i lang="en">parser</i> preditivo determinístico, ou seja, sem <i lang="en">backtracking</i>. Analisadores do tipo LL possuem ainda um parâmetro <var>k</var> chamado de <i lang="en">lookahed</i>. Esse parâmetro indica a quantidade de símbolos que serão levados em consideração em um passo do algoritmo. Quanto maior é o valor de <var>k</var> mais lento é o processo de análise e, em contra partida, menor é o número de não fatorações que uma produção da gramática pode conter. Uma gramática é dita fatorada se ela não possui produções que derive sequências que inicie com o mesmo <i lang="en">token</i> por mais de um caminho.</p>
			<p>Considerando um exemplo onde <var>k</var> é igual a um, então a gramática não pode ter nenhum símbolo não fatorado. Já se <var>k</var> é igual a dois, então a gramática pode conter apenas produções com no máximo um símbolo não fatorado.</p>
			<p>A gramática do Webis descrita em <abbr lang="en" title="Extended Backus Normal Form">EBNF</abbr> é mostrada na <a href="#listagemGramaticaDoWebis">Listagem 2.1</a>.</p>
			<figure class="listagem" id="listagemGramaticaDoWebis">
				<pre>
					<ol>
						<li>programa ::= (palavra | lista | COMENTARIO)*</li>
						<li>palavra ::=</li>
						<li>    atribuicao |</li>
						<li>    instanciacao |</li>
						<li>    simbolo |</li>
						<li>    texto |</li>
						<li>    numero |</li>
						<li>    operador |</li>
						<li>    booleano</li>
						<li>lista ::= "[" (palavra | lista)* "]"</li>
						<li>simbolo ::= &lt;IDENTIFICADOR&gt;</li>
						<li>atribuicao ::= &lt;IDENTIFICADOR&gt; "associar"</li>
						<li>instanciacao ::= &lt;IDENTIFICADOR&gt; ("novo" | "nova")</li>
						<li>texto ::= &lt;TEXTO&gt;</li>
						<li>numero ::= &lt;NUMERO&gt;</li>
						<li>operador ::= "+" | "-" | "=" | "*" | "/" | "\" | "^"</li>
						<li>booleano ::= "verdadeiro" | "falso"</li>
					</ol>
				</pre>
				<figcaption>Gramática EBNF do Webis.</figcaption>
			</figure>
			<p>Os itens entre parênteses angulares são definidos através de expressões regulares e foram omitidos para facilitar a leitura e diminuir o tamanho da gramática. Seus nomes são auto-explicativos e com exceção do <code>&lt;IDENTIFICADOR&gt;</code> dispensam maiores explicações. O <code>&lt;IDENTIFICADOR&gt;</code> é uma sequência de caracteres alfanuméricos que deve iniciar por uma letra e não contem espaços.</p>
			<p>Em gramáticas do tipo LL(k), o valor mínimo de <var>k</var> é dependente da linguagem. Existem linguagens onde nem sempre é possível construir uma gramática que seja completamente fatorada, ou seja, onde <var>k</var> é igual a um. Esse é o caso do Webis que possui uma gramática do tipo LL(2). A não fatoração no Webis ocorre na produção <code>palavra</code>, pois nela é possível que um <code>&lt;IDENTIFICADOR&gt;</code> seja derivado por três caminhos diferentes: pelas produções <code>simbolo</code>, <code>atribuicao</code> e <code>instanciacao</code>.</p>
			<p>Essa não fatoração gera um não determinismo, pois o analisador não sabe por qual caminho seguir quando encontra um <code>&lt;IDENTIFICADOR&gt;</code>. Para resolver esse problema é necessário que o algoritmo possa receber como entrada os dois próximos <i lang="en">tokens</i> e não apenas um. Com isso, ao perceber um <code>&lt;IDENTIFICADOR&gt;</code>, o analisador deverá ver qual é o próximo <i lang="en">token</i> para saber por qual produção a derivação irá seguir.</p>
			<p>Apesar da gramática do Webis requerer um analisador do tipo LL(2) e este ser mais lento se comparado a um do tipo LL(1), isso não vem a ser um problema devido a boa performance dos computadores e analisadores atuais.</p>
			<h2 id="pilha"><a href="#sumario">Pilha</a></h2>
			<h2 id="primitivas"><a href="#sumario">Primitvias</a></h2>
			<h2 id="apliques"><a href="#sumario">Apliques</a></h2>
			<h2 id="modelosAgendasEAtores"><a href="#sumario">Modelos, agendas e atores</a></h2>
			<p>No Telis existe o conceito de ator. Cada ator é uma unidade independente que possui o seu próprio contexto de execução. Um ator é um exemplar de um modelo que por sua vez é composto por agendas. Já as agendas definem comportamentos inerentes ao modelo em questão. Pode-se relacionar modelos, agendas e atores com conceitos provenientes da programação orientada a objetos. Um modelo, por exemplo, pode ser relacionado com o conceito de classe. Da mesma forma, agendas estão relacionadas com métodos e atores com objetos.</p>
			<p>Um programa Telis em execução, nada mais é que a execução e interação dos diversos atores que fazem parte do programa. Cada ator é executado separadamente em sua própria <i lang="en">thread</i> e isso permite que os programadores explorem de forma natural o paralelismo. Desde os primeiros programas os alunos já utilizam programação concorrente e fazem isso de forma simples e intuitiva. Além de ter um espaço de execução próprio, os atores não possuem nenhum recurso compartilhado e possuem o seu próprio escopo de variáveis e a sua própria pilha.</p>
			<p>Na execução inicial de um programa Telis, um ator é executado e este será responsável pera criação, direta ou indireta, de todos atores que deverão ser utilizados durante o programa. Cada ator pode instanciar tantos outros atores quanto for necessário. Além disso, os atores podem, em tempo de execução, definir novos modelos, bem como definir novas agendas locais.</p>
			<figure class="listagem" id="listagemInstanciacaoDeAtor">
				<pre>
					<ul>
						<li>UmModelo novo</li>
					</ul>
				</pre>
				<figcaption>Instanciação de um ator.</figcaption>
			</figure>
			<p>As agendas definidas em um modelo contem códigos de execução. Em Telis todo modelo possui uma agenda especial, a agenda <code>iniciar</code>. Toda vez que um ator é criado, a sua agenda <code>iniciar</code> é executada. A agenda <code>iniciar</code> existe mesmo que o programador não tenha definido ela explicitamente.</p>
			<p>Em Telis os modelos e agendas são criados dinâmicamente em tempo de execução. Para realizar a criação de modelos e agendas são utilizadas as primitivas <code>incluirModelo</code> e <code>incluirAgenda</code>, respectivamente.</p>
			<figure class="listagem" id="listagemInstanciacaoDeAtor">
				<pre>
					<ul>
						<li>"mostrarTexto" [</li>
						<li>    "texto" mostrar</li>
						<li>] incluirAgenda</li>
						<li>mostrarTexto</li>
					</ul>
				</pre>
				<figcaption>Definição e execução de uma agenda local.</figcaption>
			</figure>
			<figure class="listagem" id="listagemInstanciacaoDeAtor">
				<pre>
					<ul>
						<li>"UmModelo" [</li>
						<li>    "iniciar" [</li>
						<li>        calcular </li>
						<li>    ] incluirAgenda</li>
						<li>    "calcular" [</li>
						<li>        5 2 +</li>
						<li>    ] incluirAgenda</li>
						<li>] incluirModelo</li>
					</ul>
				</pre>
				<figcaption>Definição de um modelo e suas agendas.</figcaption>
			</figure>
			<h2 id="modeloDeExecucaoWebis"><a href="#sumario">Modelo de execução</a></h2>
			<h2 id="trocaDeMensagens"><a href="#sumario">Troca de mensagens</a></h2>
		</section>
		<section class="textual">
			<h1 id="maquinaWebis"><a href="#sumario">Máquina Webis</a></h1>
			<h2 id="geracaoDeCodigo"><a href="#sumario">Geração de código JavaScript</a></h2>
			<p>As etapas de análise léxica, sintática e geração do código do Webis serão realizadas através da ferramenta <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr>. O <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr> é um gerador de analisador léxico e sintático que pode ser utilizado para a criação de interpretadores de linguagens, compiladores e outros tradutores <cite class="parenteses"><a href="#referencia5">Parr, <time>2007</time></a></cite>. No contexto desse projeto, o <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr> será utilizado para gerar em JavaScript o código escrito em Webis. Nesse sentido, o <abbr lang="en" title="Another Tool for Language Recognition">ANTLR</abbr> atuará como um tradutor e o código JavaScript será então executado pela máquina Webis.</p>
			<p>Para realizar a geração de código JavaScript a partir de um código Webis é necessário entender alguns conceitos da arquitetura da máquina Webis que processará o código gerado. O coração da máquina Webis será explicado em detalhes mais adiante, porém por hora é necessário compreender que cada <code>palavra</code> será traduzida para um elemento JavaScript e a máquina se encarregará de executar corretamente o elemento em questão conforme o seu tipo. Por exemplo, o <code>booleano</code> do Webis, definido na <a href="#listagemGramaticaDoWebis">Listagem 2.1</a>, será traduzido para um elemento <code>Boolean</code> do JavaScript. O mesmo irá ocorrer com o <code>texto</code>, <code>numero</code> e <code>lista</code> do Webis que serão traduzidos para elementos JavaScript dos tipos <code>String</code>, <code>Number</code> e <code>Array</code>, respectivamente. Já o <code>simbolo</code>, a <code>atribuicao</code> e a <code>instanciacao</code>, ao contrário dos demais elementos, não serão traduzidos para tipos nativos do JavaScript, mas sim para os tipos próprios <code>Simbolo</code>, <code>Associar</code> e <code>Novo</code>, respectivamente. Por fim, um <code>operador</code> que semanticamente é tratado pela máquina Webis da mesma forma que um <code>simbolo</code>, também será traduzido para um objeto JavaScript do tipo <code>Simbolo</code>.</p>
			<p>Ao analisar a gramática do Webis (<a href="#listagemGramaticaDoWebis">Listagem 2.1</a>), percebemos que um programa é composto por uma lista. Essa lista por sua vez é composta por palavras e outras listas. A geração de código apenas irá essas entidades para JavaScript. Com isso, a entrada da máquina Webis será uma lista JavaScript composta por números, textos, booleanos, listas e objetos.</p>
			<h2 id="excecoes"><a href="#sumario">Exceções</a></h2>
			<p>Devido ao fato da gramática Webis ser bastante simples, ocorrem poucas exceções em tempo de compilação. Em geral, a maioria das construções sintáticas são permitidas pela linguagem e os erros de compilação se limitam a: listas não fechadas, utilização de caracteres inválidos e textos não iniciados ou terminados por aspas. O código da <a href="#listagemErroDeCompilacao">Listagem 3.1</a> mostra um erro de compilação onde um texto não foi terminado por aspas.</p>
			<figure class="listagem" id="listagemErroDeCompilacao">
				<pre>
					<ul>
						<li>"texto " "qualquer concatenar</li>
					</ul>
				</pre>
				<figcaption>Erro de compilação do Webis.</figcaption>
			</figure>
			<p>A maioria das exceções Webis ocorrem, no entanto, na etapa de execução e são gerados pela máquina Webis. As incoerências semânticas são tratadas todas durante o processo de execução e é por isso que apenas exceções de erros sintáticos são lançadas durante o processo de compilação. O código da <a href="#listagemErroDeExecucao">Listagem 3.2</a> mostra um erro de execução. O erro ocorre, pois na linguagem Webis o operador de exponenciação não pode ser aplicado a textos.</p>
			<figure class="listagem" id="listagemErroDeExecucao">
				<pre>
					<ul>
						<li>10 "texto" ^</li>
					</ul>
				</pre>
				<figcaption>Erro de excução do Webis.</figcaption>
			</figure>
			<h2 id="modeloDeExecucaoJavaScript"><a href="#sumario">Modelo de execução JavaScript em navegadores web</a></h2>
			<p>O JavaScript utilizado a partir de um navegador <i lang="en">web</i> possui fundamentalmente um fluxo único de execução fazendo com que não exista execução concorrente de código. Mais adiante será mostrado que o <abbr lang="en" title="Hypertext Markup Language 5">HTML5</abbr> trouxe o conceito de <i lang="en">Web Workers</i> que permite criar vários fluxos de execução. Entretanto, na abordagem atual será deixado de lado a utilização dos <i lang="en">Web Workers</i> e será considerado um fluxo único de execução associado a um único ator Webis.</p>
			<p>Quando um pedaço de código JavaScript é executado, ele não será interrompido até que seja finalizado. Durante a execução de um código JavaScript, eventos assíncronos podem ser disparados. O código associado a cada um desses eventos será executado, um de cada vez, somente depois que o código em execução terminar. O modelo de execução JavaScript é dito bloqueante, pois interrupções não param a execução atual de código. Em vez disso, as interrupções são guardadas para que possam ser chamadas após o término da execução atual <cite class="parenteses"><a href="#referencia8">Resig; Bibeault, <time>2013</time></a></cite>. Por interrupções pode-se considerar tanto o tratamento de <a href="#eventos">eventos</a> gerados pelo navegador quanto o disparo de <a href="#temporizadores">temporizadores</a>.</p>
			<h3 id="eventos"><a href="#sumario">Eventos</a></h3>
			<p>A criação de eventos assíncronos pode ocorrer de diversas formas. O JavaScript executado em um navegador <i lang="en">web</i> permite o uso da programação dirigida a eventos. Nesse sentido, o navegador gera eventos sempre que algo que possa ser de interesse do programador aconteça. Esses eventos estão sempre associados a algum elemento e podem ser adicionados tratadores para cada um deles. Por exemplo, um evento pode ser o clique do <i lang="en">mouse</i> em um determinado botão, o carregamento de um documento ou até mesmo o pressionamento de uma tecla.</p>
			<p>A adição de um tratador para um determinado evento de um elemento pode ser feita através do método <code>addEventListener</code> (<a href="#listagemTratadorDeEvento">Listagem 3.3</a>). Esse método irá receber dois parâmetros: o tipo do evento e uma função que contém o código do tratador. Por sua vez, quando chamado, o tratador receberá como parâmetro um objeto que representa o evento em questão.</p>
			<figure class="listagem" id="listagemTratadorDeEvento">
				<pre>
					<ul>
						<li>elemento.addEventListner("click", function (evento) {</li>
						<li>    // código do tratador...</li>
						<li>});</li>
					</ul>
				</pre>
				<figcaption>Criação de um tratador de evento.</figcaption>
			</figure>
			<h3 id="temporizadores"><a href="#sumario">Temporizadores</a></h3>
			<p>Além de eventos, também é possível utilizar temporizadores para executar pedaços de código de forma assíncrona. Da mesma forma que ocorre com os eventos, os temporizadores somente podem ser disparados quando não existir nenhum outro pedaço de código em execução. Se no momento em que um temporizador tiver que ser disparado já existir algum código em execução, então o disparo deverá ser adiado.</p>
			<p>Existem basicamente dois tipos de temporizadores: aqueles que são disparados apenas uma única vez e aqueles que são disparados continuamente a cada determinado período de tempo. Ambos tipos de temporizadores podem ser cancelados. Para criar um temporizador que é disparado uma única vez utiliza-se a função <code>setTimeout</code> presente no objeto global <code>window</code>. De forma análoga, para criar um temporizador que é disparado continuamente a cada intervalo de tempo, utiliza-se a função <code>setInverval</code> do mesmo objeto.</p>
			<figure class="listagem" id="listagemTemporizador">
				<pre>
					<ul>
						<li>var identificador = window.setTimetout(function () {</li>
						<li>    // código do tratador...</li>
						<li>}, 1000);</li>
					</ul>
				</pre>
				<figcaption>Ativação de um temporizador que será disparado após um período de tempo.</figcaption>
			</figure>
			<p>A <a href="#listagemTemporizador">Listagem 3.4</a> mostra a ativação de um temporizador que quando disparado irá executar a função que é passada como parâmetro. O segundo parâmetro indica o tempo, a partir do momento da ativação, até que o temporizador seja efetivamente disparado. No casso em questão, o tempo de espera até o disparo será de 1 segundo (ou 1000 milisegundos). Destaca-se o fato de que esse tempo de espera não é garantido. Por exemplo, se o código que realizou a ativação do temporizador continue a executar por mais de um segundo, então o temporizador ativado terá seu disparo adiado. Como já visto anteriormente o modelo de exeução do JavaScript em navegadores <i lang="en">web</i> é bloqueante. Por isso, mesmo que seja hora de disparar um temporizador, é possível que algum outro código esteja em execução no momento e, nesse caso, o disparo deverá ser adiado.</p>
			<figure class="listagem" id="listagemTemporizadorContinuo">
				<pre>
					<ul>
						<li>var identificador = window.setInterval(function () {</li>
						<li>    // código do tratador...</li>
						<li>}, 1000);</li>
					</ul>
				</pre>
				<figcaption>Ativação de um temporizador que será disparado continuamente a cada período de tempo.</figcaption>
			</figure>
			<p>A <a href="#listagemTemporizador">Listagem 3.5</a> mostra a ativação de um temporizador semelhante ao mostrado na <a href="#listagemTemporizador">Listagem 3.4</a>. A diferença entre ambos está no fato de que no caso deste último, o temporizador será disparado uma única vez após um determinado período de tempo, enquanto que no primeiro o disparo irá ocorrer continuamente a cada período de tempo.</p>
			<p>Ambos temporizadores podem ser cancelados a qualquer momento e, por isso, as duas funções para criação de temporizadores retornam um <code>identificador</code> que é utilizado pelas funções <code>clearTimeout</code> e <code>clearInterval</code>. A <a href="#listagemCancelamentoDeTemporizador">Listagem 3.6</a> mostra o cancelamento de um temporizador e de um temporizador contínuo previamente ativados</p>
			<figure class="listagem" id="listagemCancelamentoDeTemporizador">
				<pre>
					<ul>
						<li>window.clearTimeout(identificador1);</li>
						<li>window.clearInterval(identificador2);</li>
					</ul>
				</pre>
				<figcaption>Cancelamento de temporizadores previamente ativados.</figcaption>
			</figure>
			<h3 id="execucaoEmFluxoUnico"><a href="#sumario">Execução em fluxo único</a></h3>
			<p>Devido ao natureza de execução em fluxo único, apenas um pedaço de código é executado por vez no JavaScript. Assim que uma página <i lang="en">web</i> encontra um código JavaScript, ela irá carregar, analisar e por fim executar o código em questão.</p>
			<p>O fluxo único de execução responsável por executar o código JavaScript também é responsável pela redenrização do documento no navegador. Isso significa que enquanto um pedaço de código estiver sendo executado, não será realizada a renderização do documento e o inverso também é verdadeiro. Essa exclusão mútua é justificada pelo fato de que é possível manipular o documento através do JavaScript. A execução de determinada parte de código não bloqueia apenas a execução de outras partes, mas também a interface gráfica com o usuário e a execução de qualquer evento ou temporizador.</p>
			<p>A <a href="#figuraExecucaoEmFluxoUnico">Figura 3.1</a> facilita a compreensão do modelo de execução. Ela representa a linha temporal de execução do JavaScript em um navegador <i lang="en">web</i>. Cada bloco representa um pedaço de código JavaScript em execução e o tamanho do bloco indica quanto tempo durou a execução do bloco em questão. No lado direito da imagem são indicados disparos e ativações de temporizadores e ocorrências de eventos. Nota-se também que alguns disparos são cancelados (<i lang="en">dropped</i>). O a explicação detalhada da <a href="#figuraExecucaoEmFluxoUnico">Figura 3.1</a> é dada a seguir:</p>
			<ol>
				<li>No instante de tempo 0 é executado um bloco de código JavaScript que dura até o instante de tempo 18. Durante a execução desse código ocorre a ativação (mas não o disparo) de dois temporizadores, sendo um deles um temporizador contínuo. Além dos temporizadores, também ocorre um evento relacionado ao clique do <i lang="en">mouse</i>. Já no instante de tempo 12, deveria ocorrer o disparo do temporizador anteriormente ativado, porém isso não acontece, pois o proprio código que ativou o temporizador ainda está em execução. Com isso, o disparo do temporizador é adiado, assim como o tratamento do evento do <i lang="en">mouse</i>.</li>
				<li>Ao encerrar a execução do bloco de código no instante de tempo 18, o próximo passo é escalonar o próximo bloco de execução. O navegador percebe que naquele momento existem dois blocos de código possíveis de serem executados: o tratamento de um evento do <i lang="en">mouse</i> e o disparo do temporizador. O navegador opta por escalonar o tratamento do evento do <i lang="en">mouse</i>.</li>
				<li>Durante o tratamento do evento do <i lang="en">mouse</i>, que dura do instante de tempo 18 ao 29, deveria ocorrer o disparo do temporizador contínuo (previamente ativado), porém, assim como ocorreu no passo 1 com o temporizador, o temporizador contínuo também é adiado para posterior execução.</li>
				<li>Após o encerramento do tratamento do evento no instante de tempo 29, é necessário escalonar uma novo pedeço de código para executar. Nesse momento exsitem dois candidados esperando para serem executados: um temporizador e um temporizador contínuo. O temporizador é, então, escalonado.</li>
				<li>Durante a execução do temporizador, no instante de tempo 30, deveria ocorrer o disparo de um temporizador contínuo, entrentando isso não acontece, pois já há um código em execução.  Nota-se também que o disparo do temporizador contínuo é cancelado, pois já existe um disparo agendado para o mesmo temporizador contínuo.</li>
				<li>Após o término da execução do temporizador no instante de tempo 37, o único pedeço de código que está aguardando para ser executado é o temporizador contínuo e, com isso, ele é escalonado para execução. A execução do temporizador contínuo dura até o instante de tempo 41. Durante essa execução o mesmo temporizador contínuo é disparado. Porém, como já exsite um código em execução, o novo disparo é adiado.</li>
				<li>A execução do temporizador contínuo é terminada no instante de tempo 41. Após isso, o navegador escalona para execução o único pedeço de código pendente: o mesmo temporizador contínuo.</li>
				<li>O temporizador contínuo executa do instante de tempo 41 até 45. Após o término da sua execução o nevegador verifica que não há nenhum pedaço de código com execução pendente. Com isso, nenhum código é executado.</li>
				<li>No instante de tempo 50 ocorre novamente o disparo do temporizador contínuo. Como não há nenhum código em execução, o temporizador contínuo é imediatamente escalonado.</li> 
			</ol>
			<figure class="figura" id="figuraExecucaoEmFluxoUnico">
				<img src="imagens/modeloDeExecucaoJavaScript.png" />
				<figcaption>Modelo de execuçao JavaScript em fluxo único.</figcaption>
			</figure>
			<h3 id="webWorkers"><a href="#sumario">Web Workers e paralelismo</a></h3>
			<p><i lang="en">Web Worker</i> é uma nova funcionalidade já presente em alguns navegadores <i lang="en">web</i> que faz parte das novas recomendações do <abbr lang"en" title="Hypertext Markup Language 5">HTML5</abbr> pelo <dfn lang="en">Web Hypertext Application Technology Working Group <abbr title="Web Hypertext Application Technology Working Group">WHATWG</abb></dfn>. Os <i lang="en">Web Workers</i> permitem que uma página possa executar vários fluxos JavaSricpt ao mesmo tempo ao invés do tradicional fluxo único.</p>
			<p>Um <i lang="en">Web Worker</i> consiste de um pedaço de código JavaScript que executará concorrentemente com o fluxo principal. O fluxo principal, por sua vez, é responsável pela interação com a interface gráfica e pela execução dos <i lang="en">scripts</i> que são definidos na página carregada. Uma particulariedade dos <i lang="en">scripts</i> que executam através de <i lang="en">Web Workers</i> em relação aos que executam no fluxo principal é que no primeiro caso os <i lang="en">scripts</i> não tem acesso a alguns objetos globais como <code>window</code> e <code>document</code> e nem ao <dfn lang="en">Document Object Model <abbr title="Document Object Model">DOM</abbr></dfn>.</p>
			<p>Apesar de não possuir acesso direto ao <abbr lang="en" title="Document Object Model">DOM</abbr> ou as interfaces presentes na especificação deste <cite class="parenteses"><a href="#referencia10">Kesteren; Gregor; Ms2ger, <time>2013</time></a></cite>, os <i lang="en">Workers</i> podem se comunicar com <i lang="en">scripts</i> que estejam executando no fluxo principal e que por sua vez tenham acesso ao <abbr lang="en" title="Document Object Model">DOM</abbr>. A comunicação entre <i lang="en">Web Workers</i> e <i lang="en">scripts</i> do fluxo principal ocorre de forma assíncrona. O envio de mensagens de um para o outro se dá através da função <code>postMessage</code> que recebe como parâmetro qualquer valor que possa ser serializável como <dfn lang="en">JavaScript Object Notation <abbr title="JavaScript Object Notation">JSON</abbr></dfn>. Já o recebimento de mensagens é feito através da adição de um tratador para o evento <code>"message"</code>.</p>
			<p>A criação de um <i lang="en">Worker</i> é feita através da instanciação de um objeto do tipo <code>WebWorker</code>. O construtor recebe como parâmetro uma <abbr title="Uniform Resource Locator">URL</abbr> que contém o endereço do <i lang="en">script</i> que será executado pelo <i lang="en">Worker</i>. Podem ser criados tantos <i lang="en">Web Workers</i> quanto for desejado sendo que cada um deles será executado em um fluxo separado. As listagens <a href="listagemCriacaoDoWebWorker">3.7</a> e <a href="listagemWebWorker">3.8</a> representam um exemplo de utilização de <i lang="en">Web Workers</i>. No exemplo em questão o <i lang="en">script</i> executando no fluxo principal gera um numero aleatório e envia este número para o <i lang="en">Worker</i>. Do outro lado, ao receber a mensagem, o <i lang="en">Worker</i> irá calcular o quadrado do número e enviar a resposta para o <i lang="en">script</i> do fluxo principal. A <a href="listagemCriacaoDoWebWorker">Listagem 3.7</a> representa a página contento o <i lang="en">script</i> que é executado no fluxo principal e é responsável pela criação do <i lang="en">Worker</i>. Já a <a href="listagemWebWorker">Listagem 3.8</a> representa o <i lang="en">script</i> a ser executado no <i lang="en">Web Worker</i>.</p>
			<figure class="listagem" id="listagemCriacaoDoWebWorker">
				<pre>
					<ol>
						<li>&lt;!DOCTYPE html&gt;</li>
						<li>&lt;html lang="pt-br"&gt;</li>
						<li>&lt;head&gt;</li>
						<li>&lt;script type="application/javascript"&gt;</li>
						<li>    var numero = Math.random();</li>
						<li>    var worker = new WebWorker("scriptDoWorker.js");</li>
						<li>    worker.addEventListener("message",</li>
						<li>        receberResposta);</li>
						<li>    worker.postMessage(numero);</li>
						<li>    function receberResposta(numeroAoQuadrado) {</li>
						<li>        document.body.textContent = numeroAoQuadrado;</li>
						<li>    }</li>
						<li>&lt;/script&gt;</li>
						<li>&lt;/head&gt;</li>
						<li>&lt;body&gt;</li>
						<li>&lt;/body&gt;</li>
						<li>&lt;/html&gt;</li>
					</ol>
				</pre>
				<figcaption>Criação de um <i lang="en">Web Worker</i> por um <i lang="en">script</i> executando no fluxo principal.</figcaption>
			</figure>
			<figure class="listagem" id="listagemWebWorker">
				<pre>
					<ol>
						<li>self.addEventListener("message", function (numero) {</li>
						<li>    var numeroAoQuadrado = (numero * numero);</li>
						<li>    self.postMessage(numeroAoQuadrado);</li>
						<li>});</li>
					</ol>
				</pre>
				<figcaption><i lang="en">Script</i> executando através de um <i lang="en">Web Worker</i>.</figcaption>
			</figure>
			<p>Através das listagens <a href="listagemCriacaoDoWebWorker">3.7</a> e <a href="listagemWebWorker">3.8</a> percebe-se que a comunicação entre <i lang="en">workers</i> e o fluxo principal se dá de forma assíncrona através de eventos. Outro aspecto importantante é que nada é compartilhado entre um <i lang="en">worker</i> e o fluxo principal. Todo valor enviado de um para o outro através da função <code>postMessage</code> é copiado antes de ser enviado. Considerenado um exemplo onde onde um objeto é enviado através da função <code>postMessage</code>, o objeto será copiado, serializado como <abbr title="JavaScritp Object Notation">JSON</abbr>, enviado e por fim deserializado. Ou seja, na prática existirão dois objetos iguais e qualquer alteração feita em algum deles <em>não</em> afetará o outro.</p>
			<h2 id="comandos"><a href="#sumario">Comandos</a></h2>
			<p>A máquina Webis trata-se basicamente de uma máquina de pilha. Nela os parâmetros necessários para as operações são desempilhados da pilha enquanto que os resultados das operações são empilhados na mesma. A entrada da máquina Webis nada mais é do que uma lista que contém os comandos do programa, sendo que cada um desses comandos é um elemento JavaScript que saberá se executar. O coração da máquina Webis, portanto, se torna muito simples em uma primeira análise. De forma simplificada, o que o núcleo da máquina Webis faz enviar a ordem de execução para cada um dos comandos da lista recebida como entrada. Além da ordem de execução, o coração da máquina Webis fornece ao comando a ser executado o contexto do programa. Desta forma, cada comando tem acesso a pilha de dados e ao escopo de variáveis, podendo empilhar e desempilhar elementos da pilha de dados e alterar, remover e criar variáveis.</p>
			<p>A máquina Webis pode executar tanto dados quanto operações e símbolos. Quando um dado é executado ele simplesmente é colocado na pilha e fica disponível para ser consumido por uma operação ou símbolo. Quando operações ou símbolos são executados, eles podem ou não consumir elementos da pilha para produzir ou não algum resultado. Caso a operação produza algum resultado, então este é colocado na pilha de forma que possa ser consumido por uma operação ou símbolo futuro.</p>
			<p>No Webis, um símbolo pode ser uma primitiva básica fornecida pela linguagem, um operador, uma agenda de um ator ou uma variável. Quando a máquina encontra um símbolo, ela tenta executá-lo para algum desses casos. Caso a máquina não consiga executar o símbolo em questão, então uma exceção é lançada e em geral isso ocorre devido a erros de programação do usuário.</p>
			<p>Conforme mostrado na <a href="#geracaoDeCodigoJavaScipt">Seção 3.1</a>, cada elemento sintático da linguagem Webis é traduzido para um elemento JavaScript que o represente. Cada um desses elementos JavaScipt será um comando que deverá implementar o método <code>executar</code>. Esse método deverá receber como parâmetro pela máquina Webis o contexto da execução que deverá conter a pilha de dados e o escopo de variáveis.</p>
			<p>No procesos de tradução, alguns elementos, como o <code>texto</code> são traduzidos para tipo nativos do JavaScript, nesse caso para <code>String</code>. Existem também aqueles elementos sintáticos que serão traduzidos para tipos próprios, como é o caso da <code>atribuicao</code> que será traduzida para um objeto do tipo <code>Associar</code>. Um dos pontos interessantes da orientação a objetos por prototipação do JavaScript é permitir que a interface de um determinado tipo de objeto seja modificada de forma dinâmina, em tempo de execução. Por exemplo, é possível adicionar de forma dinâmica um método no protótipo <code>String</code>. É justamente essa característica que permite que todos os elementos da entrada da máquina Webis saibam se executar, inclusive tipos nativos. No caso dos tipos nativos como <code>String</code>, <code>Array</code>, <code>Number</code> e <code>Boolean</code> é adicionado de forma dinâmica ao protótipo desses tipos o método <code> executar</code>. Dessa forma, a máquina Webis poderá executar de forma polimórifca todos os comandos recebidos como entrada.</p>
			<h2 id="pilhaDeExecucao"><a href="#sumario">Pilha de execução</a></h2>
			<p>Conforme mostrado na <a href="#modeloDeExecucaoWebis">Seção 2.6</a>, o modelo de execução do Webis será não bloqueante. Isso significa que o ator poderá ser interrompido enquanto estiver em execução. Quando isso ocorrer, o ator irá parar sua execução e irá tratar a interrupção em questão. Além disso, o ator tratará apenas uma interrupção por vez e poderá perder interrupções enquanto estiver tratando outra.</p>
			<p>Uma particulariedade no modelo de execução do Webis é a primitiva <code>descansar</code>. Quando esta primitiva é executada, ela faz com que o ator fique parado por um determinado período de tempo. Entretanto, ao ter sua execução interrompida, o ator poderá continuar tratando eventuais interrupções.</p>
			<p>Através da <a href="#modeloDeExecucaoJavaScript">Seção 3.4</a> percebe-se que o modelo de execução do JavaScript difere do modelo de execução do Webis. Em especial, essas diferenças podem causar três problemas que dificultam a implementação do Webis através do JavaScript. O primeiro problema está relacionado com a primitiva <code>descansar</code>. No caso do JavaScript não é possível bloquear o programa em execução por um determinado período de tempo da mesma forma como ocorre no Java (através do método <code>sleep</code>), por exemplo. O mais próximo que se pode chegar disso é simular esse comportamento através da função <code>setTimeout</code>.</p>
			<p>O segundo problema ocorre pois o JavaScript é bloqueante e, por isso, quando um trecho de código é executado, o programa não pode ser interrompido até que o trecho termine.</p>
			<p>Por fim, o último aspecto que difere no modelo de execução do Webis e do JavaScript é que neste último nenhuma interrupção é perdida. No Webis, caso uma interrupção ocorra enquanto outra está sendo executada, então a interrupção que surgiu é descartada. Já no JavaScript se o mesmo caso ocorrer, então a nova interrupção é guardada para ser posteriormente executada.</p>
			<p>Focando no escopo de um único ator é necessário que a máquina Webis seja capaz de garantir os seguintes critérios:</p>
			<ul>
				<li>Permitir que após um ator ser instanciado, este possa receber interrupções de estímulos durante a sua execução. Quando isso ocorrer, o ator deverá parar sua execução e tratar a interrupção.</li>
				<li>Descartar interrupções que surgirem caso o ator já esteja tratando uma outra interrupção.</li>
				<li>A primitiva <code>descansar</code> deverá parar por um determinado período de tempo a execução do ator ou de uma eventual interrupção. Além disso, caso um ator esteja parado em função da primitiva e uma interrupção surja, então é necessário que o tempo de descanso estipulado pelo ator seja descontado do tempo de demora da execução da interrupção.</li>
			</ul>
			<p>A implementação de uma máquina Webis que satisfaça os critérios anteriormente mencionados é uma tarefa difícil e complexa. A implementação mais natural para a máquina Webis seria executar, através de um laço de repetição, cada comando da lista recebida como entrada da máquina. Entretanto, ao fazer isso, não seria possível receber interrupções entre a execução de um comando e outro, já que, como mostrado na <a href="#modeloDeExecucaoJavaScript">Seção 3.4</a>, o modelo de execução JavaScript é bloqueante.</p>
			<p>Para permitir que um ator possa ser interrompido durante a sua execução, é necessário que o código a ser executado seja quebrado em pequenos pedaços que serão executados assíncronamente através de temporizadores. Para isso, é necessário: decidir a granulariedade desses pequenos pedaços de código e criar um mescanismo que permita executar os comandos na ordem correta. Com o objetivo de realizar essas tarefas e facilitar a implementação, será criada uma pilha de execução que será responsável por controlar a execução correta e não bloqueante dos fragmentos atômicos de código.</p>
			<p>A <a href="figuraExecucaoSincronaEAssincrona">Figura 3.2</a> mostra a diferença entre a execução da entrada de comandos da máquina Webis de forma síncrona e bloqueante e a execução da mesma entrada de forma assíncrona e não bloqueante. A figura representa verticalmente a linha temporal de execução onde cada bloco representa comandos da máquina Webis sendo executados. Blocos hachurrados representam comandos de tratadores de interrupções, enquanto que os demais blocos representam comandos do próprio ator. É indicado também, através de setas, o recebimento de interrupções pelo ator.</p>
			<figure class="figura" id="figuraExecucaoSincronaEAssincrona">
				<img src="imagens/execucaoSincronaEAssincronaCinza.png" />
				<figcaption>Diferença entre a execução síncrona e bloqueante e a execução assíncrona e não bloqueante da máquina Webis.</figcaption>
			</figure>
			<p>Através da <a href="figuraExecucaoSincronaEAssincrona">Figura 3.2</a> fica claro a diferença entre utilizar um modelo onde a execução de todos comandos é realizada de forma síncrona e um modelo onde os comandos da máquina Webis são executados assíncronamente através de temporizadores. Destaca-se o fato de que no caso da execução síncrona, ela não respeita as restrições do modelo de execução do Webis. Nesse caso em questão, o ator somente passa a receber interrupções após ter terminado de executar todo o código a ele associado. Percebe-se também que nenhuma interrupção é perdida e ambas são recebidas e executadas uma após a outra. Já no caso da execução assíncrona, onde são utilizados temporizadores para executar pequenos trechos de código, nota-se que o ator sofre interrupções no meio de sua execução. Além disso, nesse segundo caso, o modelo de execução do Webis é respeitado, já que uma interrupção é perdida enquanto outra interrupção está sendo tratada.</p>
			<p>Um exemplo simplificado de como a máquina Webis funcionaria caso seguisse o modelo síncrono e bloqueante é mostrado na <a href="listagemModeloBloqueante">Listagem 3.7</a>. Percebe-se que nesse caso o coração da máquina Webis se torna muito simples. A única tarefa necessária é iterar sobre a lista de comandos recebidos como entrada da máquina e executar os comandos em questão passando como parâmetro para cada comando o contexto da execução. Com isso, cada comando poderá ter acesso a pilha de dados e ao escopo de variáveis.</p>
			<figure class="listagem" id="listagemCoracaoDaMaquinaSincrono">
				<pre>
					<ol>
						<li>function executar(codigo) {</li>
						<li>    var contexto = new Contexto();</li>
						<li>    codigo.each(function (comando) {</li>
						<li>        comando.executar(contexto);</li>
						<li>    });</li>
						<li>}</li>
					</ol>
				</pre>
				<figcaption>Exemplo de um implementação síncrona e bloquenate para o núcleo da máquina Webis</figcaption>
			</figure>
			<p>Ao contrário do modelo síncrono e bloqueante e que não está em conformidade com o modelo de execução do Webis, a implementação do modelo assíncrono e não bloqueante não é trivial. É necessário ter um controle sobre a execução assíncrona para que se possa garantir que os comandos executem na ordem correta. Além disso, primitivas de controle de fluxo como <code>enquantoVerdade</code> precisarão ser quebradas em vários pedaços para impedir que uma dessas primitivas venham a travar o ator por muito tempo. Se isso acontecer, o ator não poderá receber interrupções enquanto a primitiva de controle de fluxo estiver executando. Por isso, o bloco de comandos executados dentro de uma primitiva de controle de fluxo também precisará ser quebrado em vários pequenos comandos atômicos, da mesma forma como deve ocorrer com a entrada da máquina.</p>
			<h3 id="padraoEstado"><a href="#sumario">Padrão estado</a></h3>
			<p>Para realizar a implementação do núcleo da máquina Webis de modo que este funcione de forma assíncrona e não bloqueante e respeite o modelo de execução do Webis, será utilizada uma pilha de execução. A pilha de execução deverá garantir a ordem correta de execução dos comandos e deverá executar um comando de cada vez de forma assíncrona, permitindo que o ator possa receber interrupções.</p>
			<p>Uma característica bem clara da pilha de execução é a presença de diferentes estados para diferentes momentos da sua existência. Dependendo do momento, a pilha de execução poderá ter um estado diferente e deverá reagir de forma diferente em cada estado. Por exemplo, a pilha de execução pode estar no estado <strong>interrompido</strong> ou no estado <strong>encerrado</strong> e dependedo em qual destes estados ela estiver, deverá responder de forma diferente à chamada do método <code>retomar</code>.</p>
			<p>A caracterização da pilha de execução como um elemento composto por diversos estados traz a possibilidade da utilização do padrão de projeto estado para a realização da implementação. O padrão de projeto estado tem por objetivo permitir que um objeto altere seu comportamento quando seu estado interno é aterado <cite class="parenteses"><a href="#referencia9">Gamma, <time>1995</time></a></cite>. A <a href="figuraPadraoEstado">Figura 3.3</a> mostra o diagrama de classes do padrão estado. Na figura são identificados, através da modelagem <abbr title="">UML</abbr>, os componentes que fazem parte do padrão:</p>
			<ul>
				<li><strong>Contexto</strong>: define as operações que podem ser utilizadas e mantém uma instância de um <code>EstadoConcreto</code> que representa o estado atual.</li>
				<li><strong>Estado</strong>: contém a interface de operações que deverá ser implementada por cada <code>EstadoConcreto</code>.</li>
				<li>Subclasses <strong>EstadoConcreto</strong>: representam classes que implementam a interface <code>Estado</code> e possuem diferentes comportamentos para os diferentes métodos da interface.</li>
			</ul>
			<figure class="figura">
				<img src="imagens/padraoEstado.jpg" />
				<figcaption>Diagrama de classes do padrão estado.</figcaption>
			</figure>
			<p>Para realizar a implementação será criada a classe <code>PilhaDeExecucao</code> que representará o <code>Contexto</code> do padrão estado. A classe criada deverá possuir internamente o estado atual que poderá ser representado pelas classes: <code>EstadoNaoIniciado</code>, <code>EstadoExecucao</code>, <code>EstadoInterrompido</code> e <code>EstadoEncerrado</code>. Quando a <code>PilhaDeExecucao</code> for chamada, ela deverá acionar o estado atual para concluir a operação. Os estados também serão responsáveis por modificar o estado atual da <code>PilhaDeExecucao</code>.</p>
			<p>A <a href="figuraDiagramaDeEstadosDaPilhaDeExecucao">Figura 3.4</a> mostra o diagrama de estados da pilha de execução. As setas indicam operações que ao serem acionadadas acarretarão na mudança de um estado para outro.</p>
			<figure class="figura" id="figuraDiagramaDeEstadosDaPiluaDeExecucao">
				<img src="imagens/diagramaDeEstadosDaPilhaDeExecucao.png" />
				<figcaption>Diagrama de estados da pilha de execução.</figcaption>
			</figure>
			<h3 id="pilhaDeComandos"><a href="#sumario">Pilha de comandos</a></h3>
			<p>A pilha de <strong>execução</strong> conterá uma pilha de <strong>comandos</strong> que serão executados a partir do topo da pilha. Isso permitirá que durante a execução do ator ou de uma interrupção, novos comandos sejam empilhados para que também possam ser executados. Esse mecanismo tem especial importância para o caso das primitivas que precisam executar listas de comandos e para outras primitivas que são compostas por vários comandos.</p>
			<p>Antes de analisar a aplicabilidade da pilha de <strong>comandos</strong> é necessário compreender alguns conceitos da linguagem. É preciso ter em mente que no Webis as listas podem conter tanto dados quanto comandos. Quando executadas, as listas são colocadas na pilha de <storng>dados</strong> para que possam ser utilizadas por outras primitivas. É importante perceber que quando uma lista é executada, os comandos que eventualmente estejam dentro dela não são executados. Os comandos dentro de uma lista somente serão executados se uma primitiva Webis der explicitamente tal ordem.</p>
			<p>Primitivas Webis necessitam executar listas por vários motivos. No caso das primitivas de controle de fluxo, os comandos que devem ser executados pela primitiva são buscados na pilha de <strong>dados</strong> e devem estar dentro de uma lista. Nesse caso, a primitiva de controle de fluxo precisa executar todos os comandos que estejam dentro da lista que foi buscada na pilha de <strong>dados</strong>.</p>
			<p>Outra necessidade da execução dos comandos contidos em uma lista ocorre com as primitivas de controle de fluxo que envolvem testes condicionais. No Webis todo valor pode ser avaliado como booleano, inclusive uma lista. A avaliação de uma lista como booleano consiste em executar todos comandos que fazem parte dela e avaliar o valor final. A <a href="listagemAvaliacaoDeLista">Listagem 3.10</a> mostra o exemplo de uma lista que quando avaliada resultará em <code>verdadeiro</code>. As primitivas que realizam testes condicionais simplismente buscam o operando no topo da pilha de <strong>dados</strong> para realizar o teste. Caso esse operando seja uma lista, então a primitiva deverá executar todos comandos dentro dela para que a avaliação possa ser realizada.</p>
			<p>É importante lembrar que a máquina Webis deverá executar de forma assíncrona os comandos para permitir que o ator possa sofrer interrupções durante a sua execução. Outro aspecto é que cada uma das execuções assíncronas deverá ocorrer o mais rápido possível e deverá possuir a granulariedade máxima de um comando da máquina Webis. Devido a esse fato, será necessário dividir em várias execuções assíncronas ao invés de apenas uma todas aquelas primitivas que são compostas por mais de um comando da máquina Webis ou que necessitam executar os vários comandos dentro de uma lista. Sem essa divisão a restrição de granulariedade máxima de um comando Webis por execução assíncrona não seria respeitada e o ator poderia ficar impedido de receber interrupções por um período de tempo muito longo.</p>
			<p>As primitivas de repetição possuem um problema extra para serem implementadas no que se refere ao modelo de execuções assíncronas do Webis. Para respeitar o modelo não deve ser possível que uma primitiva de repetição realize mais de uma repetição por execução assíncrona de código. Por isso, para realizar a sua implementanção, uma primitiva de repetição  deverá adicionar os seguintes itens à pilha de <strong>comandos</strong>: os comandos que devem ser executados a cada repetição e um comando extra de verificação. A tarefa do comando extra será a de analisar se deverá ou não ser realizada mais uma repetição. Em caso positivo, então o comando extra deverá adicionar novamente à pilha de <strong>comandos</strong> os mesmos itens anteriores. Esse ciclo somente terminará quando o bloco de verificação concluir que não existem mais repetições a serem realizadas. Nesse caso, o bloco de verificação apenas deixará de colocar qualquer item na pilha de <strong>comandos</strong> e a execução seguirá normalmente através da execução do comando seguinte à primitiva de repetição.</p>
			<p>Assim, o mecanismo da pilha de execução que permite adicionar novos comandos no topo da pilha é justificado pois permite que primitivas que precisam executar itens de uma lista e primitivas de repetição respeitem o modelo de execução do Webis.</p>
			</ul>
			<figure class="listagem" id="listagemAvaliacaoDeLista">
				<pre>
					<ul>
						<li>[10 5 maiorQue]</li>
					</ul>
				</pre>
				<figcaption>Lista Webis que quando avaliada executará cada um dos dados e comandos dentro dela e resultará em verdadeiro.</figcaption>
			</figure>
			<h3 id="janelaDeTempo"><a href="#sumario">Janela de tempo</a></h3>
			<h2 id="ecossistema"><a href="#sumario">Ecossistema</a></h2>
		</section>
		<section class="posTextual">
			<h1 id="referencias"><a href="#sumario">Referências bibliográficas</a></h1>
			<p id="referencia1">
				GOMES, Anabela; MENDES, A. J.
				<strong lang="en">Learning to program</strong>:
				<span lang="en">difficulties and solutions</span>.
				<span lang="en">International Conference on Engineering Education</span>,
				Coimbra, Portugal, 2007.
			</p>
			<p id="referencia2">
				PIERI, Giovani <i lang="la">et al</i>.
				<strong lang="en">Telis</strong>:
				<span lang="en">a programming tool set for beginners</span>.
				<span lang="en">International Information And Telecommunication Technologies Symposium</span>, Florianópolis, Santa Catarina, Brasil, 2009. p. 183-186.
			</p>
			<p id="referencia3">
				SAVISKI, Marcelo.
				<strong>Porte de uma linguagem de programação para execução nativa em navegadores Web</strong>.
				Curso de Ciências da Computação, Departamento de Informática e Estatística, Universidade Federal de Santa Catarina,
				Florianópolis, Santa Catarina, Brasil, 2010.
			</p>
			<p id="referencia4">
				PIERI, Giovani.
				<strong>Projeto e implementação de uma linguagem de programação</strong>.
				Curso de Ciências da Computação, Departamento de Informática e Estatística, Universidade Federal de Santa Catarina,
				Florianópolis, Santa Catarina, Brasil, 2007.
			</p>
			<p id="referencia5">
				PARR, Terence.
				<strong lang="en">The definitive ANTLR reference</strong>:
				<span lang="en">Building domain-specific languages</span>.
				<span lang="en">The Pragmatic Bookshelf</span>,
				2007. 358 p.
			</p>
			<p id="referencia6">
				SMITH, Ann C. <i lang="la">et al</i>.
				<strong lang="en">A Java programming tool for students with visual disabilities</strong>.
				<span lang="en">Proceedings of the fourth international ACM conference on Assistive technologies</span>,
				Arlington, Virginia, USA, 2000. p. 142-148.
			</p>
			<p id="referencia7">
				SÁNCHEZ, Jaime; AGUAYO, Fernando.
				<strong lang="en">Blind learners programming through audio</strong>.
				<span lang="en">CHI '05 Extended Abstracts on Human Factors in Computing Systems</span>,
				Portland, OR, USA, 2005. p. 1769-1772.
			</p>
			<p id="referencia8">
				RESIG, John; BIBEAULT, Bear.
				<strong lang="en">Screts of the JavaScript ninja</strong>.
				<span lang="en">Manning Publications</span>,
				Shelter Island, NY, USA, 2013. 370 p.
			</p>
			<p id="referencia9">
				GAMMA, Erich <i lang="la">et al</i>.
				<strong lang="en">Desìng Patterns</strong>:
				<span lang="en">Elements of Reusable Object-Oriented Software</span>.
				<span lang="en">Addison Wesley</span>,
				1997. p. 305-313.
			</p>
			<p id="referencia10">
				KESTEREN, A.; GREGOR A.; MS2GER.
				<strong lang="en"><abbr="Document Object Model">DOM</abbr></strong>.
				<span lang="en">Web Hypertext Application Technology Working Group</span>,
				2013.
				Disponível em: <a href="http://dom.spec.whatwg.org">http://dom.spec.whatwg.org</a>.
				Acesso em: setembro de 2013.
			</p>
			<p id="referencia99">
				CALDWELL, Ben <i lang="la">et al</i>.
				<strong lang="en">Web Content Accessibility Guidelines 2.0</strong>.
				<span lang="en">World Wide Web Consortium</span>,
				2008.
				Disponível em: <a href="http://www.w3.org/TR/WCAG">http://www.w3.org/TR/WCAG</a>.
				Acesso em: dezembro de 2012.
			</p>
			<p id="referencia98">
				XAVIER, Marcus Vinícius Cruz.
				<strong>Telis ME</strong>: uma versão de Telis para dispositivos móveis.
				Curso de Ciências da Computação, Departamento de Informática e Estatística, Universidade Federal de Santa Catarina,
				Florianópolis, Santa Catarina, Brasil, 2006.
			</p>
		</section>
	</body>
</html>